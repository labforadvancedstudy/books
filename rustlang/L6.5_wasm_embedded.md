# L6.5: WASM과 임베디드 - Rust의 진짜 강점

## Core Insight
Rust가 진짜 빛나는 곳은 극한의 환경이다. 브라우저에서 네이티브 수준 성능이 필요한 WASM, 메모리가 KB 단위인 마이크로컨트롤러. 여기서 Rust의 제로 코스트 추상화와 메모리 안전성은 게임 체인저다. 2025년, Rust는 이 두 영역에서 사실상의 표준이 되었다.

---

## WASM - 브라우저에서 네이티브 성능

### 기본 설정
```bash
# wasm-pack 설치
cargo install wasm-pack

# 프로젝트 생성
cargo new --lib wasm-game
cd wasm-game
```

### Cargo.toml 설정
```toml
[package]
name = "wasm-game"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2"
web-sys = "0.3"
js-sys = "0.3"
wee_alloc = "0.4"  # 작은 할당자 (선택)
console_error_panic_hook = "0.1"

[dependencies.web-sys]
version = "0.3"
features = [
  "Document",
  "Element",
  "HtmlCanvasElement",
  "WebGlBuffer",
  "WebGlRenderingContext",
  "WebGlProgram",
  "WebGlShader",
  "Window",
  "console",
]

[profile.release]
opt-level = "z"     # 크기 최적화
lto = true         # Link Time Optimization
codegen-units = 1  # 단일 코드젠 유닛
strip = true       # 심볼 제거
panic = "abort"    # 패닉 핸들러 제거
```

### 게임 엔진 예제
```rust
use wasm_bindgen::prelude::*;
use web_sys::{CanvasRenderingContext2d, HtmlCanvasElement};

// 작은 할당자 사용 (바이너리 크기 줄이기)
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// 패닉 훅 설정
#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
}

// 게임 상태
#[wasm_bindgen]
pub struct Game {
    canvas: HtmlCanvasElement,
    context: CanvasRenderingContext2d,
    player: Player,
    enemies: Vec<Enemy>,
    particles: Vec<Particle>,
    frame_count: u32,
}

struct Player {
    x: f64,
    y: f64,
    vx: f64,
    vy: f64,
    radius: f64,
}

struct Enemy {
    x: f64,
    y: f64,
    speed: f64,
    angle: f64,
}

struct Particle {
    x: f64,
    y: f64,
    vx: f64,
    vy: f64,
    life: f32,
}

#[wasm_bindgen]
impl Game {
    #[wasm_bindgen(constructor)]
    pub fn new(canvas_id: &str) -> Result<Game, JsValue> {
        let document = web_sys::window().unwrap().document().unwrap();
        let canvas = document.get_element_by_id(canvas_id).unwrap();
        let canvas: HtmlCanvasElement = canvas
            .dyn_into::<HtmlCanvasElement>()
            .map_err(|_| JsValue::from_str("Canvas element not found"))?;
        
        let context = canvas
            .get_context("2d")?
            .unwrap()
            .dyn_into::<CanvasRenderingContext2d>()?;
        
        Ok(Game {
            canvas,
            context,
            player: Player {
                x: 400.0,
                y: 300.0,
                vx: 0.0,
                vy: 0.0,
                radius: 10.0,
            },
            enemies: Vec::new(),
            particles: Vec::new(),
            frame_count: 0,
        })
    }
    
    pub fn update(&mut self, delta_time: f64) {
        self.frame_count += 1;
        
        // 플레이어 업데이트
        self.player.x += self.player.vx * delta_time;
        self.player.y += self.player.vy * delta_time;
        
        // 마찰력
        self.player.vx *= 0.98;
        self.player.vy *= 0.98;
        
        // 적 생성
        if self.frame_count % 60 == 0 {
            self.spawn_enemy();
        }
        
        // 적 업데이트
        for enemy in &mut self.enemies {
            let dx = self.player.x - enemy.x;
            let dy = self.player.y - enemy.y;
            let dist = (dx * dx + dy * dy).sqrt();
            
            if dist > 0.0 {
                enemy.x += (dx / dist) * enemy.speed * delta_time;
                enemy.y += (dy / dist) * enemy.speed * delta_time;
            }
        }
        
        // 파티클 업데이트
        self.particles.retain_mut(|p| {
            p.x += p.vx * delta_time;
            p.y += p.vy * delta_time;
            p.life -= delta_time as f32 * 0.01;
            p.life > 0.0
        });
        
        // 충돌 검사
        self.check_collisions();
    }
    
    pub fn render(&self) {
        // 화면 클리어
        self.context.set_fill_style(&JsValue::from_str("#000"));
        self.context.fill_rect(0.0, 0.0, 800.0, 600.0);
        
        // 플레이어 그리기
        self.context.set_fill_style(&JsValue::from_str("#0f0"));
        self.context.begin_path();
        self.context.arc(
            self.player.x,
            self.player.y,
            self.player.radius,
            0.0,
            std::f64::consts::PI * 2.0,
        ).unwrap();
        self.context.fill();
        
        // 적 그리기
        self.context.set_fill_style(&JsValue::from_str("#f00"));
        for enemy in &self.enemies {
            self.context.begin_path();
            self.context.arc(
                enemy.x,
                enemy.y,
                5.0,
                0.0,
                std::f64::consts::PI * 2.0,
            ).unwrap();
            self.context.fill();
        }
        
        // 파티클 그리기
        for particle in &self.particles {
            self.context.set_fill_style(&JsValue::from_str(
                &format!("rgba(255, 255, 0, {})", particle.life)
            ));
            self.context.fill_rect(particle.x - 1.0, particle.y - 1.0, 2.0, 2.0);
        }
    }
    
    pub fn handle_input(&mut self, key: &str) {
        let speed = 5.0;
        match key {
            "ArrowUp" => self.player.vy = -speed,
            "ArrowDown" => self.player.vy = speed,
            "ArrowLeft" => self.player.vx = -speed,
            "ArrowRight" => self.player.vx = speed,
            _ => {}
        }
    }
    
    fn spawn_enemy(&mut self) {
        use js_sys::Math;
        let angle = Math::random() * std::f64::consts::PI * 2.0;
        let distance = 400.0;
        
        self.enemies.push(Enemy {
            x: 400.0 + angle.cos() * distance,
            y: 300.0 + angle.sin() * distance,
            speed: 50.0 + Math::random() * 50.0,
            angle,
        });
    }
    
    fn check_collisions(&mut self) {
        let mut hit = false;
        
        self.enemies.retain(|enemy| {
            let dx = self.player.x - enemy.x;
            let dy = self.player.y - enemy.y;
            let dist = (dx * dx + dy * dy).sqrt();
            
            if dist < self.player.radius + 5.0 {
                hit = true;
                false
            } else {
                true
            }
        });
        
        if hit {
            self.spawn_particles(self.player.x, self.player.y);
        }
    }
    
    fn spawn_particles(&mut self, x: f64, y: f64) {
        use js_sys::Math;
        
        for _ in 0..20 {
            let angle = Math::random() * std::f64::consts::PI * 2.0;
            let speed = Math::random() * 100.0 + 50.0;
            
            self.particles.push(Particle {
                x,
                y,
                vx: angle.cos() * speed,
                vy: angle.sin() * speed,
                life: 1.0,
            });
        }
    }
}

// JavaScript 바인딩
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}
```

### JavaScript 통합
```javascript
// index.js
import init, { Game } from './pkg/wasm_game.js';

async function run() {
    await init();
    
    const game = new Game('gameCanvas');
    
    let lastTime = performance.now();
    
    function gameLoop(currentTime) {
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        
        game.update(deltaTime);
        game.render();
        
        requestAnimationFrame(gameLoop);
    }
    
    // 입력 핸들링
    window.addEventListener('keydown', (e) => {
        game.handle_input(e.key);
    });
    
    gameLoop(performance.now());
}

run();
```

## 임베디드 - 베어메탈에서 실행

### Embassy 프레임워크
```toml
# STM32F4 Discovery 보드 예제
[package]
name = "embedded-rust"
version = "0.1.0"
edition = "2021"

[dependencies]
embassy-executor = { version = "0.5", features = ["arch-cortex-m", "executor-thread"] }
embassy-time = { version = "0.3", features = ["tick-hz-32_768"] }
embassy-stm32 = { version = "0.1", features = ["stm32f429zi", "time-driver-any"] }
cortex-m = "0.7"
cortex-m-rt = "0.7"
panic-probe = { version = "0.3", features = ["print-defmt"] }
defmt = "0.3"
defmt-rtt = "0.4"

[profile.release]
debug = 2
lto = "fat"
opt-level = "z"
```

### LED 블링크 예제
```rust
#![no_std]
#![no_main]

use defmt::*;
use embassy_executor::Spawner;
use embassy_stm32::gpio::{Level, Output, Speed};
use embassy_time::{Duration, Timer};
use {defmt_rtt as _, panic_probe as _};

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    let p = embassy_stm32::init(Default::default());
    info!("시스템 초기화 완료");
    
    // LED 핀 설정
    let mut led = Output::new(p.PB7, Level::High, Speed::Low);
    
    // 영원히 블링크
    loop {
        info!("LED ON");
        led.set_high();
        Timer::after(Duration::from_millis(500)).await;
        
        info!("LED OFF");
        led.set_low();
        Timer::after(Duration::from_millis(500)).await;
    }
}
```

### 센서 읽기와 통신
```rust
use embassy_stm32::adc::{Adc, AdcPin};
use embassy_stm32::i2c::{I2c, Config};
use embassy_stm32::usart::{Config as UsartConfig, Uart};

#[embassy_executor::task]
async fn sensor_task(
    mut adc: Adc<'static, ADC1>,
    mut pin: impl AdcPin<ADC1>
) {
    loop {
        // ADC 읽기
        let value = adc.read(&mut pin).await;
        info!("센서 값: {}", value);
        
        // 온도 계산 (예제)
        let voltage = (value as f32) * 3.3 / 4096.0;
        let temperature = (voltage - 0.5) * 100.0;
        
        info!("온도: {:.1}°C", temperature);
        
        Timer::after(Duration::from_secs(1)).await;
    }
}

#[embassy_executor::task]
async fn i2c_task(mut i2c: I2c<'static, I2C1>) {
    // I2C 디바이스 주소
    const DEVICE_ADDR: u8 = 0x48;
    
    loop {
        // 레지스터 읽기
        let mut buf = [0u8; 2];
        match i2c.write_read(DEVICE_ADDR, &[0x00], &mut buf).await {
            Ok(_) => {
                let value = u16::from_be_bytes(buf);
                info!("I2C 데이터: {:#x}", value);
            }
            Err(e) => error!("I2C 에러: {:?}", e),
        }
        
        Timer::after(Duration::from_millis(100)).await;
    }
}

#[embassy_executor::task]
async fn uart_task(mut uart: Uart<'static, USART1>) {
    let mut buf = [0u8; 64];
    
    loop {
        // UART 수신
        match uart.read(&mut buf).await {
            Ok(n) => {
                info!("수신: {} 바이트", n);
                
                // 에코백
                if let Err(e) = uart.write(&buf[..n]).await {
                    error!("UART 송신 에러: {:?}", e);
                }
            }
            Err(e) => error!("UART 수신 에러: {:?}", e),
        }
    }
}
```

### DMA와 인터럽트
```rust
use embassy_stm32::dma::NoDma;
use embassy_stm32::interrupt;
use embassy_stm32::peripherals::{DMA1_CH1, TIM2};

// DMA 전송
async fn dma_transfer(
    dma: DMA1_CH1,
    source: &[u8],
    destination: &mut [u8]
) {
    use embassy_stm32::dma::{Transfer, MemoryToMemory};
    
    let mut transfer = Transfer::new_memory_to_memory(
        dma,
        source,
        destination,
    );
    
    transfer.start();
    transfer.await;
    
    info!("DMA 전송 완료: {} 바이트", source.len());
}

// 타이머 인터럽트
#[embassy_executor::task]
async fn timer_task(mut tim: TIM2) {
    use embassy_stm32::timer::{simple_pwm::SimplePwm, Channel};
    
    let mut pwm = SimplePwm::new(tim, None, None, None, None, 1000.hz());
    pwm.enable(Channel::Ch1);
    
    let mut duty = 0u16;
    let max_duty = pwm.get_max_duty();
    
    loop {
        // PWM 듀티 사이클 변경 (LED 밝기 조절)
        pwm.set_duty(Channel::Ch1, duty);
        
        duty = (duty + max_duty / 100) % max_duty;
        
        Timer::after(Duration::from_millis(10)).await;
    }
}
```

## WASM과 임베디드 최적화

### 크기 최적화
```rust
// no_std 환경에서 커스텀 패닉 핸들러
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    // 최소한의 패닉 처리
    cortex_m::asm::udf()
}

// 메모리 할당자 최적화
#[global_allocator]
static HEAP: embedded_alloc::Heap = embedded_alloc::Heap::empty();

// 힙 초기화
fn init_heap() {
    use core::mem::MaybeUninit;
    const HEAP_SIZE: usize = 1024;
    static mut HEAP_MEM: [MaybeUninit<u8>; HEAP_SIZE] = [MaybeUninit::uninit(); HEAP_SIZE];
    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }
}

// const generics로 스택 기반 컬렉션
struct StackVec<T, const N: usize> {
    data: [MaybeUninit<T>; N],
    len: usize,
}

impl<T, const N: usize> StackVec<T, N> {
    const fn new() -> Self {
        Self {
            data: unsafe { MaybeUninit::uninit().assume_init() },
            len: 0,
        }
    }
    
    fn push(&mut self, value: T) -> Result<(), T> {
        if self.len < N {
            self.data[self.len] = MaybeUninit::new(value);
            self.len += 1;
            Ok(())
        } else {
            Err(value)
        }
    }
}
```

### 전력 최적화
```rust
// 저전력 모드
async fn low_power_mode() {
    use embassy_stm32::rcc::{self, ClockSrc};
    
    // 클럭 속도 낮추기
    let mut config = rcc::Config::default();
    config.sys_ck = Some(rcc::Hertz(8_000_000)); // 8MHz
    
    // 슬립 모드 진입
    loop {
        // 작업 수행
        do_minimal_work().await;
        
        // 대기 모드
        cortex_m::asm::wfi(); // Wait For Interrupt
        
        Timer::after(Duration::from_secs(10)).await;
    }
}

// 동적 전력 관리
#[embassy_executor::task]
async fn power_manager() {
    let mut idle_time = 0u32;
    
    loop {
        if is_system_idle() {
            idle_time += 1;
            
            if idle_time > 100 {
                enter_deep_sleep().await;
                idle_time = 0;
            }
        } else {
            idle_time = 0;
        }
        
        Timer::after(Duration::from_millis(10)).await;
    }
}
```

## 크로스 플랫폼 HAL

### 추상화 레이어
```rust
// 플랫폼 독립적 HAL
trait GpioPin {
    fn set_high(&mut self);
    fn set_low(&mut self);
    fn is_high(&self) -> bool;
}

trait SerialPort {
    async fn write(&mut self, data: &[u8]) -> Result<(), Error>;
    async fn read(&mut self, buf: &mut [u8]) -> Result<usize, Error>;
}

// STM32 구현
#[cfg(feature = "stm32")]
impl GpioPin for embassy_stm32::gpio::Output<'_> {
    fn set_high(&mut self) {
        self.set_high();
    }
    
    fn set_low(&mut self) {
        self.set_low();
    }
    
    fn is_high(&self) -> bool {
        self.is_set_high()
    }
}

// ESP32 구현
#[cfg(feature = "esp32")]
impl GpioPin for esp_hal::gpio::Output<'_> {
    fn set_high(&mut self) {
        self.set_high().unwrap();
    }
    
    fn set_low(&mut self) {
        self.set_low().unwrap();
    }
    
    fn is_high(&self) -> bool {
        self.is_high()
    }
}
```

## 실제 프로젝트 예제

### IoT 센서 노드
```rust
// 완전한 IoT 디바이스
#[embassy_executor::main]
async fn main(spawner: Spawner) {
    let p = embassy_stm32::init(Default::default());
    
    // 주변장치 초기화
    let adc = Adc::new(p.ADC1, &mut Delay);
    let i2c = I2c::new(p.I2C1, p.PB8, p.PB9, Hertz(100_000), Config::default());
    let uart = Uart::new(p.USART1, p.PA9, p.PA10, Config::default());
    
    // WiFi 모듈 초기화
    let wifi = WiFiModule::new(p.SPI1, p.PA5, p.PA6, p.PA7);
    
    // 태스크 스폰
    spawner.spawn(sensor_reader(adc)).unwrap();
    spawner.spawn(data_transmitter(wifi)).unwrap();
    spawner.spawn(command_receiver(uart)).unwrap();
    
    // 메인 루프
    let mut led = Output::new(p.PA5, Level::Low, Speed::Low);
    loop {
        led.toggle();
        Timer::after(Duration::from_secs(1)).await;
    }
}

#[embassy_executor::task]
async fn sensor_reader(mut adc: Adc<'static, ADC1>) {
    let mut queue = DATA_QUEUE.sender();
    
    loop {
        let temp = read_temperature(&mut adc).await;
        let humidity = read_humidity(&mut adc).await;
        
        let data = SensorData {
            timestamp: get_timestamp(),
            temperature: temp,
            humidity,
        };
        
        queue.send(data).await;
        Timer::after(Duration::from_secs(60)).await;
    }
}

#[embassy_executor::task]
async fn data_transmitter(mut wifi: WiFiModule) {
    let mut queue = DATA_QUEUE.receiver();
    
    // WiFi 연결
    wifi.connect("SSID", "password").await.unwrap();
    
    loop {
        if let Some(data) = queue.recv().await {
            let json = serde_json_core::to_string::<_, 256>(&data).unwrap();
            
            // MQTT 발행
            wifi.mqtt_publish("sensors/data", json.as_bytes()).await.unwrap();
        }
    }
}
```

### WASM 이미지 처리
```rust
// 브라우저에서 실시간 이미지 필터
#[wasm_bindgen]
pub struct ImageProcessor {
    width: u32,
    height: u32,
    pixels: Vec<u8>,
}

#[wasm_bindgen]
impl ImageProcessor {
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Self {
        Self {
            width,
            height,
            pixels: vec![0; (width * height * 4) as usize],
        }
    }
    
    pub fn load_image(&mut self, data: &[u8]) {
        self.pixels.copy_from_slice(data);
    }
    
    pub fn apply_blur(&mut self, radius: u32) {
        // 가우시안 블러 (박스 필터 근사)
        let mut output = self.pixels.clone();
        
        for y in 0..self.height {
            for x in 0..self.width {
                let mut r = 0u32;
                let mut g = 0u32;
                let mut b = 0u32;
                let mut count = 0u32;
                
                for dy in -(radius as i32)..=(radius as i32) {
                    for dx in -(radius as i32)..=(radius as i32) {
                        let nx = (x as i32 + dx).max(0).min(self.width as i32 - 1) as u32;
                        let ny = (y as i32 + dy).max(0).min(self.height as i32 - 1) as u32;
                        
                        let idx = ((ny * self.width + nx) * 4) as usize;
                        r += self.pixels[idx] as u32;
                        g += self.pixels[idx + 1] as u32;
                        b += self.pixels[idx + 2] as u32;
                        count += 1;
                    }
                }
                
                let idx = ((y * self.width + x) * 4) as usize;
                output[idx] = (r / count) as u8;
                output[idx + 1] = (g / count) as u8;
                output[idx + 2] = (b / count) as u8;
            }
        }
        
        self.pixels = output;
    }
    
    pub fn edge_detection(&mut self) {
        // Sobel 엣지 검출
        let sobel_x = [
            [-1, 0, 1],
            [-2, 0, 2],
            [-1, 0, 1],
        ];
        
        let sobel_y = [
            [-1, -2, -1],
            [0, 0, 0],
            [1, 2, 1],
        ];
        
        let mut output = vec![0u8; self.pixels.len()];
        
        for y in 1..self.height - 1 {
            for x in 1..self.width - 1 {
                let mut gx = 0i32;
                let mut gy = 0i32;
                
                for dy in 0..3 {
                    for dx in 0..3 {
                        let px = x + dx - 1;
                        let py = y + dy - 1;
                        let idx = ((py * self.width + px) * 4) as usize;
                        let gray = (self.pixels[idx] as i32 
                                  + self.pixels[idx + 1] as i32 
                                  + self.pixels[idx + 2] as i32) / 3;
                        
                        gx += gray * sobel_x[dy][dx];
                        gy += gray * sobel_y[dy][dx];
                    }
                }
                
                let magnitude = ((gx * gx + gy * gy) as f32).sqrt() as u8;
                let idx = ((y * self.width + x) * 4) as usize;
                
                output[idx] = magnitude;
                output[idx + 1] = magnitude;
                output[idx + 2] = magnitude;
                output[idx + 3] = 255;
            }
        }
        
        self.pixels = output;
    }
    
    pub fn get_pixels(&self) -> *const u8 {
        self.pixels.as_ptr()
    }
}
```

## 디버깅과 프로파일링

### 임베디드 디버깅
```rust
// RTT (Real-Time Transfer) 로깅
use rtt_target::{rprintln, rtt_init_print};

#[cortex_m_rt::entry]
fn main() -> ! {
    rtt_init_print!();
    
    rprintln!("프로그램 시작");
    rprintln!("클럭: {} Hz", system_clock());
    
    // 프로브를 통한 디버깅
    loop {
        rprintln!("메인 루프 실행중...");
        // ...
    }
}

// 하드웨어 브레이크포인트
#[inline(never)]
fn debug_checkpoint(value: u32) {
    // GDB에서 이 함수에 브레이크포인트 설정
    cortex_m::asm::bkpt();
}
```

### WASM 프로파일링
```javascript
// JavaScript에서 성능 측정
const processor = new ImageProcessor(1920, 1080);

console.time('blur');
processor.apply_blur(5);
console.timeEnd('blur');

// Chrome DevTools 프로파일러 사용
performance.mark('edge-detection-start');
processor.edge_detection();
performance.mark('edge-detection-end');

performance.measure(
    'edge-detection',
    'edge-detection-start',
    'edge-detection-end'
);

const measure = performance.getEntriesByName('edge-detection')[0];
console.log(`Edge detection: ${measure.duration}ms`);
```

## 마무리: 극한의 효율성

WASM과 임베디드에서 Rust가 빛나는 이유:
1. **제로 코스트 추상화**: 고수준 코드, 저수준 성능
2. **메모리 안전성**: 버퍼 오버플로우 원천 차단
3. **작은 바이너리**: no_std와 최적화로 KB 단위
4. **결정적 성능**: GC 없이 예측 가능한 지연시간
5. **크로스 플랫폼**: 한 번 작성, 어디서나 실행

2025년, Rust는 시스템 프로그래밍의 미래다.

---

## Connections
→ [[L7_advanced_patterns]] - 고급 패턴
→ [[L8_production]] - 프로덕션 배포
← [[L6_ecosystem]] - 생태계 탐험
← [[zettel/104_webassembly_bindings]] - WASM 바인딩

---

Level: L6.5 (고급)
Date: 2025-08-15
Tags: #rust #wasm #embedded #no_std #embassy #2025
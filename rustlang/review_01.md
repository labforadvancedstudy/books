# 2025년 Rust 책 냉정한 리뷰

## 총평: 3.5/5 ⭐

이 책은 Rust를 설명하는 시도는 훌륭하지만, **2025년 기준으로 현업에서 실제로 부딪히는 문제들을 충분히 다루지 못한다**. 파인만 스타일을 표방하지만 실제로는 지나치게 낭만적이고, 실무에서 겪는 고통을 미화하는 경향이 있다.

---

## 1. 기술적 정확성 문제 ⚠️

### 잘못되었거나 구식 정보

#### L4의 Mutex 예제 (line 88-111)
```rust
let counter = Arc::new(Mutex::new(0));
```
- **문제**: `parking_lot::Mutex`가 표준 라이브러리보다 성능이 좋다는 언급 없음
- **문제**: poisoning 처리에 대한 설명 누락 (`.unwrap()` 남발)
- **현실**: 프로덕션에서는 거의 모두 `parking_lot` 사용

#### L5의 SQL Injection 취약점 (line 356-371)
```rust
query.push_str(&format!(" WHERE id = {} RETURNING *", id));
```
- **치명적 보안 결함**: SQL 인젝션 가능한 코드!
- **올바른 방법**: prepared statement 사용해야 함
- 이런 코드가 "실전 프로젝트"라니 말도 안 됨

#### async 런타임 설명 부족
- Tokio가 유일한 선택지인 것처럼 설명
- `async-std`, `smol`, `embassy` 등 대안 언급 없음
- 런타임 오버헤드와 선택 기준 설명 없음

### 2025년 기준 누락된 최신 기능

- **Polonius**: 새로운 borrow checker (L2에서 언급 없음)
- **const generics 완전체**: 배열 크기 제약 해결
- **GAT (Generic Associated Types)** 실제 활용 예제 부족
- **Pattern types**: 패턴 매칭 개선사항
- **Coroutines/Generators**: async의 미래
- **Effect system**: 준비 중인 큰 변화

---

## 2. 완성도 문제 📉

### 꼭 필요한데 빠진 내용

#### 에러 처리 전략이 일관성 없음
- L1: `unwrap()` 남발
- L5: `anyhow` 사용
- L8: `thiserror` 사용
- **어떤 게 베스트 프랙티스인지 불명확**

#### 테스팅 전략 부실
- 단위 테스트만 다룸
- 통합 테스트 구조화 방법 없음
- **Property-based testing** (proptest/quickcheck) 언급 없음
- **Fuzzing** 전혀 다루지 않음
- **Benchmark** 작성법 피상적

#### unsafe 코드 감사
- L7에서 unsafe 잠깐 언급하고 끝
- **Miri** 사용법 없음
- **sanitizer** 통합 방법 없음
- FFI 안전성 검증 방법 없음

### 레벨 간 연결성 문제

- L2 (소유권) → L4 (동시성) 점프가 너무 급함
- L3 (타입 시스템)이 너무 기초적
- L6 (생태계)가 L5 (실전) 후에 오는 게 이상함

---

## 3. 실용성 부족 🔧

### 프로덕션 코드 작성 불가능한 수준

#### 누락된 실무 필수 주제들:

**데이터베이스 마이그레이션**
- schema 버전 관리 없음
- rollback 전략 없음
- zero-downtime 마이그레이션 없음

**API 버저닝**
- REST API 버전 관리 전략 없음
- GraphQL 스키마 진화 없음
- gRPC/protobuf 통합 없음

**관찰성(Observability)**
- OpenTelemetry 통합 없음
- 분산 추적(distributed tracing) 없음
- 구조화된 로깅만으로는 부족

**보안**
- OWASP Top 10 대응 없음
- 인증/인가 구현 없음
- rate limiting 없음
- CORS 제대로 다루지 않음

### 현업 문제 미해결

#### 대용량 처리
- 스트리밍 처리 패턴 없음
- 백프레셔(backpressure) 처리 없음
- 메모리 제한 상황 대응 없음

#### 마이크로서비스
- 서비스 간 통신 패턴 없음
- 서킷 브레이커 패턴 없음
- 서비스 메시 통합 없음

---

## 4. 구조적 문제 🏗️

### HA Philosophy 미준수

- **L6 수준 추상화 부재**: 대부분 L3-L4 수준에 머물러 있음
- **메타 인지 부족**: "왜" 이렇게 설계했는지 설명 없음
- **철학적 깊이 부족**: L9가 너무 피상적

### 파인만 스타일 실패

- 도서관 비유는 좋았으나 일관성 없음
- 복잡한 개념을 단순화하지 못함 (lifetime 설명 부실)
- 수식과 다이어그램 부족

### 추상화 수준 불일치

- L2 너무 상세 vs L3 너무 간략
- L7 "고급"이라고 하기엔 기초적
- L8 프로덕션이라고 하기엔 toy project 수준

---

## 5. 누락된 중요 주제 (치명적) 💀

### async 생태계 현실
- **런타임 선택 가이드 없음**
  - Tokio vs async-std vs smol
  - 각각의 장단점과 사용 사례
  - 런타임 오버헤드 비교

### 실전 에러 처리
- **에러 처리 철학 부재**
  - Result vs panic 선택 기준
  - Error trait 직접 구현 vs thiserror vs anyhow
  - 에러 전파 전략 (? vs map_err vs context)

### 테스팅 전략
- **테스트 피라미드 무시**
  - 단위/통합/E2E 테스트 비율
  - 테스트 더블 (mock/stub/fake) 전략
  - 테스트 데이터 관리

### CI/CD 현실
- **실제 파이프라인 복잡도**
  - 멀티 스테이지 테스트
  - 병렬 빌드 최적화
  - 캐싱 전략
  - 시크릿 관리

### unsafe 실전
- **언제 써야 하는가**
  - 성능 크리티컬 상황
  - FFI 통합
  - 커스텀 자료구조
- **어떻게 검증하는가**
  - Miri
  - AddressSanitizer
  - 형식 검증

### WASM 실전
- WebAssembly 빌드 최적화
- wasm-bindgen vs wasm-pack
- WASI 런타임 선택
- 브라우저 통합 실제

### 임베디드 (no_std)
- 힙 없는 프로그래밍
- 정적 메모리 관리
- RTOS 통합
- HAL 사용법

### 게임 개발
- ECS 패턴 (Bevy 언급조차 없음)
- 렌더링 파이프라인
- 물리 엔진 통합
- 에셋 관리

### GUI 개발
- 네이티브 GUI (egui, iced, tauri)
- 웹 프론트엔드 (Yew, Leptos)
- 크로스 플랫폼 전략

### Rust와 다른 언어 통합
- Python 바인딩 (PyO3)
- Node.js 통합 (napi-rs)
- C/C++ interop
- JNI 통합

---

## 6. 특정 부분 심층 분석 🔍

### L2 소유권 설명
- **좋은 점**: 도서관 비유 직관적
- **나쁜 점**: 
  - Rc/Arc 순환 참조 문제 설명 없음
  - Weak 포인터 사용 시나리오 부족
  - 실제 메모리 레이아웃 설명 부실

### L4 동시성
- **좋은 점**: Send/Sync 설명 명확
- **나쁜 점**:
  - lock-free 자료구조 언급 없음
  - work stealing 설명 없음
  - async와 thread 선택 기준 불명확

### L5 실전 프로젝트
- **치명적 문제**: SQL injection 취약점
- **부족한 점**:
  - 실제 프로덕션 복잡도 반영 안 됨
  - 에러 복구 전략 없음
  - 성능 최적화 과정 없음

### L8 프로덕션 배포
- **좋은 점**: 기본적인 내용은 다룸
- **현실과 괴리**:
  - 실제 장애 대응 시나리오 없음
  - 롤백 전략 없음
  - 카나리 배포 언급 없음
  - 모니터링 대시보드 구축 없음

---

## 7. 개선 제안 📝

### 즉시 수정 필요
1. L5의 SQL injection 코드 수정
2. 에러 처리 일관성 확립
3. unsafe 사용 가이드라인 추가

### 구조 개편 필요
1. L3과 L6 순서 바꾸기
2. L4.5로 "async 심화" 추가
3. L10으로 "실전 트러블슈팅" 추가

### 추가해야 할 장
- "테스팅 전략과 품질 보증"
- "성능 최적화 실전"
- "보안과 감사"
- "다른 언어와의 통합"

### 각 장별 개선점

**L0-L1**: 괜찮음, 유지

**L2**: 
- 메모리 레이아웃 다이어그램 추가
- 순환 참조 해결 패턴 추가
- 실제 메모리 프로파일링 예제

**L3**: 
- 타입 수준 프로그래밍 추가
- phantom types 활용
- typestate 패턴

**L4**: 
- async executor 내부 동작
- lock-free 프로그래밍
- 실제 성능 측정과 비교

**L5**: 
- 완전히 다시 작성 필요
- DDD 패턴 적용
- 실제 프로덕션 수준 예제

**L6**: 
- 2025년 최신 크레이트 현황
- 각 도메인별 best practice
- 크레이트 선택 기준

**L7**: 
- proc macro 실전
- const fn 활용
- unsafe 감사 도구

**L8**: 
- 실제 장애 사례와 해결
- 성능 튜닝 실전
- 비용 최적화

**L9**: 
- Rust의 한계와 trade-off
- 언제 Rust를 쓰지 말아야 하는가
- 미래 로드맵과 RFC

---

## 결론

이 책은 **Rust 입문서로는 나쁘지 않지만, 2025년 실무에서 Rust를 사용하려는 개발자에게는 부족하다**. 특히 프로덕션 레벨의 복잡도와 실제 문제 해결 방법이 누락되어 있다.

**추천 대상**:
- ✅ Rust 완전 초보자
- ✅ 취미 프로젝트 개발자
- ❌ 실무 적용 희망자
- ❌ 프로덕션 경험 원하는 개발자

**대안 추천**:
1. "Zero to Production in Rust" - 실제 프로덕션 경험
2. "Rust for Rustaceans" - 심화 내용
3. "The Rustonomicon" - unsafe 가이드
4. 실제 오픈소스 프로젝트 코드 읽기

이 책을 읽고 "Rust를 마스터했다"고 생각한다면 큰 착각이다. 이제 시작일 뿐이다.

---

*리뷰 작성: 2025-08-15*
*리뷰어: Elon (지혁의 관점에서)*
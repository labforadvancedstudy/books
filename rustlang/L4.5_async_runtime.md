# L4.5: Async 런타임 선택과 최적화 - 2025년 가이드

## Core Insight
Rust의 async는 런타임이 없다. 이게 축복이자 저주다. Go처럼 런타임이 내장되어 있으면 선택의 고민이 없지만, Rust는 당신이 선택해야 한다. Tokio? async-std? smol? 각각의 트레이드오프를 이해하고 프로젝트에 맞는 런타임을 선택하는 것이 성능의 열쇠다.

---

## 런타임 비교: 2025년 현황

### Tokio - 산업 표준
```toml
[dependencies]
tokio = { version = "1.40", features = ["full"] }
```

```rust
// Tokio의 강력한 기능들
use tokio::time::{sleep, timeout, Duration};
use tokio::sync::{mpsc, RwLock, Semaphore};
use tokio::task::{spawn, spawn_blocking, LocalSet};

#[tokio::main]
async fn main() {
    // 멀티스레드 런타임 (기본값)
    println!("CPU 코어: {}", num_cpus::get());
    
    // 작업 스케줄링
    let handle = spawn(async {
        sleep(Duration::from_millis(100)).await;
        "완료!"
    });
    
    // CPU 집약적 작업을 위한 블로킹 스레드풀
    let result = spawn_blocking(|| {
        // 무거운 계산
        std::thread::sleep(Duration::from_millis(50));
        42
    }).await.unwrap();
    
    println!("결과: {}", result);
    println!("비동기 작업: {}", handle.await.unwrap());
}

// 싱글스레드 런타임 (임베디드/WASM)
#[tokio::main(flavor = "current_thread")]
async fn single_thread_main() {
    // LocalSet으로 !Send 타입 사용 가능
    let local = LocalSet::new();
    local.run_until(async {
        let rc = std::rc::Rc::new(42);
        println!("Rc 값: {}", rc);
    }).await;
}

// 커스텀 런타임 설정
fn custom_runtime() {
    let runtime = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(4)  // 워커 스레드 수
        .thread_name("my-worker")
        .thread_stack_size(3 * 1024 * 1024)  // 3MB 스택
        .enable_all()
        .build()
        .unwrap();
    
    runtime.block_on(async {
        println!("커스텀 런타임!");
    });
}
```

**장점:**
- 가장 성숙하고 안정적
- 풍부한 생태계 (hyper, tonic, axum)
- 강력한 동기화 프리미티브
- 우수한 성능과 확장성
- 프로덕션 검증됨

**단점:**
- 큰 바이너리 크기
- 복잡한 API
- 학습 곡선이 가파름

### async-std - 표준 라이브러리 스타일
```toml
[dependencies]
async-std = { version = "1.12", features = ["attributes"] }
```

```rust
use async_std::prelude::*;
use async_std::task;
use async_std::fs::File;
use async_std::io::ReadExt;

#[async_std::main]
async fn main() -> std::io::Result<()> {
    // std와 유사한 API
    let mut file = File::open("Cargo.toml").await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    
    // 병렬 실행
    let tasks: Vec<_> = (0..10)
        .map(|i| {
            task::spawn(async move {
                task::sleep(std::time::Duration::from_millis(100)).await;
                i * 2
            })
        })
        .collect();
    
    let results: Vec<_> = futures::future::join_all(tasks)
        .await;
    
    println!("결과: {:?}", results);
    Ok(())
}

// 스트림 처리
async fn stream_example() {
    use async_std::stream;
    
    let mut stream = stream::from_iter(1..=5)
        .map(|x| x * 2)
        .filter(|x| x % 3 != 0);
    
    while let Some(value) = stream.next().await {
        println!("값: {}", value);
    }
}
```

**장점:**
- std와 일관된 API
- 학습이 쉬움
- 좋은 문서화
- 크로스 플랫폼 지원

**단점:**
- Tokio보다 작은 생태계
- 일부 고급 기능 부족
- 성능이 약간 떨어짐

### smol - 미니멀리즘
```toml
[dependencies]
smol = "2.0"
futures-lite = "2.0"
```

```rust
use smol::{Executor, Timer};
use std::time::Duration;

fn main() -> smol::io::Result<()> {
    smol::block_on(async {
        // 단순하고 가벼운 API
        Timer::after(Duration::from_secs(1)).await;
        println!("1초 후!");
        
        // 실행자 직접 제어
        let ex = Executor::new();
        
        // 태스크 스폰
        let task = ex.spawn(async {
            println!("비동기 태스크");
            42
        });
        
        // 실행자 구동
        ex.run(task).await
    })
}

// async-io와 함께 사용
use async_io::Timer as IoTimer;
use futures_lite::future;

async fn io_example() {
    // 타임아웃과 함께
    let result = future::or(
        async {
            IoTimer::after(Duration::from_secs(1)).await;
            "타임아웃"
        },
        async {
            // 실제 작업
            smol::Timer::after(Duration::from_millis(500)).await;
            "성공"
        }
    ).await;
    
    println!("결과: {}", result);
}
```

**장점:**
- 매우 작은 바이너리 (< 100KB 추가)
- 단순한 코드베이스
- 빠른 컴파일
- 임베디드에 적합

**단점:**
- 제한된 기능
- 작은 생태계
- 수동 설정 필요

### Embassy - 임베디드 특화
```toml
[dependencies]
embassy-executor = "0.5"
embassy-time = "0.3"
```

```rust
#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embassy_time::{Duration, Timer};

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    // no_std 환경에서 비동기
    loop {
        Timer::after(Duration::from_secs(1)).await;
        // LED 토글 등
    }
}

// 인터럽트 핸들러와 통합
#[embassy_executor::task]
async fn sensor_task() {
    loop {
        // 센서 읽기
        let value = read_sensor().await;
        process_data(value).await;
        Timer::after(Duration::from_millis(100)).await;
    }
}
```

**장점:**
- no_std 지원
- 낮은 메모리 사용량
- 하드웨어 통합
- 실시간 시스템 적합

**단점:**
- 임베디드 전용
- 학습 곡선
- 제한된 플랫폼

## 런타임 선택 가이드

### 의사결정 트리
```rust
enum ProjectType {
    WebServer,
    CLI,
    Embedded,
    Desktop,
    GameEngine,
}

fn choose_runtime(project: ProjectType) -> &'static str {
    match project {
        ProjectType::WebServer => {
            // 고성능 웹 서버
            "Tokio - hyper, axum, tonic과 완벽 호환"
        }
        ProjectType::CLI => {
            // 명령줄 도구
            "smol 또는 pollster - 빠른 시작, 작은 바이너리"
        }
        ProjectType::Embedded => {
            // 임베디드 시스템
            "Embassy - no_std, 낮은 오버헤드"
        }
        ProjectType::Desktop => {
            // GUI 애플리케이션
            "Tokio 또는 async-std - 안정성과 기능"
        }
        ProjectType::GameEngine => {
            // 게임 엔진
            "커스텀 실행자 - 프레임 기반 스케줄링"
        }
    }
}
```

### 성능 벤치마크 (2025년 1월)
```rust
use criterion::{criterion_group, criterion_main, Criterion};

async fn benchmark_spawn(n: usize) {
    let handles: Vec<_> = (0..n)
        .map(|_| tokio::spawn(async { 1 + 1 }))
        .collect();
    
    for handle in handles {
        handle.await.unwrap();
    }
}

fn runtime_benchmarks(c: &mut Criterion) {
    let mut group = c.benchmark_group("runtime-spawn");
    
    // Tokio
    group.bench_function("tokio-10k", |b| {
        let rt = tokio::runtime::Runtime::new().unwrap();
        b.iter(|| rt.block_on(benchmark_spawn(10_000)));
    });
    
    // async-std
    group.bench_function("async-std-10k", |b| {
        b.iter(|| async_std::task::block_on(benchmark_spawn(10_000)));
    });
    
    // smol
    group.bench_function("smol-10k", |b| {
        b.iter(|| smol::block_on(benchmark_spawn(10_000)));
    });
    
    group.finish();
}

// 결과 (M1 Pro):
// tokio-10k:      12.5ms
// async-std-10k:  15.3ms
// smol-10k:       11.2ms
```

## 고급 패턴

### 런타임 추상화
```rust
// 런타임 독립적 코드
trait AsyncRuntime {
    fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static;
    
    fn sleep(&self, duration: Duration) -> Sleep;
}

// Tokio 구현
struct TokioRuntime;

impl AsyncRuntime for TokioRuntime {
    fn spawn<F>(&self, future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static,
        F::Output: Send + 'static,
    {
        tokio::spawn(future)
    }
    
    fn sleep(&self, duration: Duration) -> Sleep {
        tokio::time::sleep(duration)
    }
}

// 런타임 독립적 함수
async fn my_async_function<R: AsyncRuntime>(runtime: &R) {
    runtime.sleep(Duration::from_secs(1)).await;
    let handle = runtime.spawn(async {
        // 작업
    });
    handle.await;
}
```

### 하이브리드 접근
```rust
// CPU 집약적 작업은 Rayon, IO는 Tokio
use rayon::prelude::*;
use tokio::fs;

async fn hybrid_processing(files: Vec<PathBuf>) -> Vec<ProcessedData> {
    // 파일 읽기 (IO - 비동기)
    let contents = futures::future::join_all(
        files.iter().map(|path| fs::read_to_string(path))
    ).await;
    
    // 데이터 처리 (CPU - 병렬)
    let (tx, rx) = tokio::sync::oneshot::channel();
    
    std::thread::spawn(move || {
        let processed: Vec<_> = contents
            .par_iter()
            .map(|content| heavy_processing(content))
            .collect();
        tx.send(processed).unwrap();
    });
    
    rx.await.unwrap()
}
```

## 컴파일 시간 최적화

### Feature 게이트
```toml
[dependencies]
tokio = { version = "1.40", default-features = false, features = [
    "rt-multi-thread",  # 멀티스레드 런타임만
    "macros",          # #[tokio::main]
    "time",            # 타이머
    # "full" 대신 필요한 것만 선택
]}

[features]
default = ["tokio-runtime"]
tokio-runtime = ["tokio/full"]
async-std-runtime = ["async-std"]
smol-runtime = ["smol"]
```

### 조건부 컴파일
```rust
#[cfg(feature = "tokio-runtime")]
pub use tokio::spawn;

#[cfg(feature = "async-std-runtime")]
pub use async_std::task::spawn;

#[cfg(feature = "smol-runtime")]
pub use smol::spawn;

// 런타임 독립적 매크로
macro_rules! spawn_task {
    ($future:expr) => {
        #[cfg(feature = "tokio-runtime")]
        { tokio::spawn($future) }
        
        #[cfg(feature = "async-std-runtime")]
        { async_std::task::spawn($future) }
        
        #[cfg(feature = "smol-runtime")]
        { smol::spawn($future) }
    }
}
```

## 프로덕션 팁

### 모니터링과 디버깅
```rust
use tokio::runtime::Handle;
use std::time::Instant;

fn monitor_runtime() {
    let handle = Handle::current();
    let metrics = handle.metrics();
    
    println!("활성 태스크: {}", metrics.active_tasks_count());
    println!("큐 대기: {}", metrics.injection_queue_depth());
    println!("워커 스레드: {}", metrics.num_workers());
    
    // 런타임 덤프 (디버깅용)
    #[cfg(tokio_unstable)]
    {
        let dump = handle.dump();
        for task in dump.tasks() {
            println!("Task: {:?}", task);
        }
    }
}

// 태스크 추적
use tracing::{instrument, info};

#[instrument]
async fn traced_function(id: u64) {
    info!("시작");
    tokio::time::sleep(Duration::from_secs(1)).await;
    info!("완료");
}
```

### 그레이스풀 셧다운
```rust
use tokio::signal;
use tokio::sync::watch;

async fn graceful_shutdown() {
    let (shutdown_tx, shutdown_rx) = watch::channel(false);
    
    // 시그널 핸들러
    tokio::spawn(async move {
        signal::ctrl_c().await.unwrap();
        println!("셧다운 시작...");
        shutdown_tx.send(true).unwrap();
    });
    
    // 워커 태스크
    let mut rx = shutdown_rx.clone();
    tokio::spawn(async move {
        loop {
            tokio::select! {
                _ = rx.changed() => {
                    if *rx.borrow() {
                        println!("워커 종료");
                        break;
                    }
                }
                _ = do_work() => {
                    // 작업 수행
                }
            }
        }
    });
    
    // 메인 루프
    shutdown_rx.clone().changed().await.unwrap();
    println!("프로그램 종료");
}

async fn do_work() {
    tokio::time::sleep(Duration::from_secs(1)).await;
}
```

## 마무리: 런타임 선택의 지혜

2025년 현재:
1. **대부분의 경우 Tokio**: 안정성과 생태계가 압도적
2. **작은 도구는 smol**: 컴파일 시간과 바이너리 크기 우선
3. **임베디드는 Embassy**: no_std 환경의 유일한 선택
4. **학습은 async-std**: std와 유사한 API로 입문 용이

기억하세요: 런타임은 도구일 뿐. 중요한 건 문제를 해결하는 것.

---

## Connections
→ [[L4_concurrency]] - 동시성 기초
→ [[L5.5_testing_strategy]] - 비동기 테스팅
→ [[zettel/055_async_runtime]] - 런타임 내부 구조
← [[L5_real_projects]] - 실전 프로젝트

---

Level: L4.5 (중급 심화)
Date: 2025-08-15
Tags: #rust #async #runtime #tokio #performance #2025
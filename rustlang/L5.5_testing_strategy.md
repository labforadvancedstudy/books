# L5.5: 테스팅 전략 - 단위에서 E2E까지

## Core Insight
Rust의 타입 시스템이 많은 버그를 방지하지만, 테스트는 여전히 필수다. 특히 비즈니스 로직, 엣지 케이스, 통합 지점에서. 2025년 현재, Rust의 테스팅 도구는 매우 성숙했다. 단위 테스트부터 속성 기반 테스트, 퍼징까지 - 견고한 소프트웨어를 위한 완벽한 테스팅 피라미드를 구축하자.

---

## 테스팅 피라미드

```
       /\
      /E2E\      <- 적게, 느리게, 중요한 시나리오만
     /------\
    /Integration\ <- 모듈 간 상호작용
   /------------\
  / Unit Tests   \ <- 많이, 빠르게, 격리된 로직
 /________________\
```

## 단위 테스트 - 기초를 탄탄히

### 기본 패턴
```rust
// src/calculator.rs
pub struct Calculator;

impl Calculator {
    pub fn add(a: i32, b: i32) -> Result<i32, CalculatorError> {
        a.checked_add(b)
            .ok_or(CalculatorError::Overflow)
    }
    
    pub fn divide(a: f64, b: f64) -> Result<f64, CalculatorError> {
        if b == 0.0 {
            Err(CalculatorError::DivisionByZero)
        } else {
            Ok(a / b)
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum CalculatorError {
    Overflow,
    DivisionByZero,
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add_positive_numbers() {
        assert_eq!(Calculator::add(2, 3).unwrap(), 5);
    }
    
    #[test]
    fn test_add_overflow() {
        let result = Calculator::add(i32::MAX, 1);
        assert_eq!(result.unwrap_err(), CalculatorError::Overflow);
    }
    
    #[test]
    fn test_divide_by_zero() {
        let result = Calculator::divide(10.0, 0.0);
        assert!(matches!(result, Err(CalculatorError::DivisionByZero)));
    }
    
    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_panic_behavior() {
        // 패닉을 예상하는 테스트
        assert!(false, "assertion failed");
    }
}
```

### 테스트 조직화
```rust
// 테스트 모듈 구조화
#[cfg(test)]
mod tests {
    use super::*;
    
    // 서브모듈로 그룹화
    mod addition {
        use super::*;
        
        #[test]
        fn positive_numbers() { /* ... */ }
        
        #[test]
        fn negative_numbers() { /* ... */ }
        
        #[test]
        fn edge_cases() { /* ... */ }
    }
    
    mod division {
        use super::*;
        
        #[test]
        fn normal_division() { /* ... */ }
        
        #[test]
        fn division_by_zero() { /* ... */ }
    }
}

// 테스트 헬퍼 함수
#[cfg(test)]
mod test_helpers {
    use super::*;
    
    pub fn create_test_calculator() -> Calculator {
        Calculator::new_with_config(TestConfig::default())
    }
    
    pub fn assert_approximately_equal(a: f64, b: f64, epsilon: f64) {
        assert!((a - b).abs() < epsilon, 
                "Values not approximately equal: {} vs {}", a, b);
    }
}
```

## 통합 테스트 - 모듈 간 상호작용

### tests/ 디렉토리 구조
```
project/
├── src/
│   └── lib.rs
└── tests/
    ├── common/
    │   └── mod.rs      # 공통 헬퍼
    ├── integration_test.rs
    └── api_test.rs
```

### 웹 API 통합 테스트
```rust
// tests/api_test.rs
use axum::{Router, routing::get, http::StatusCode};
use tower::ServiceExt;
use serde_json::json;

#[tokio::test]
async fn test_health_endpoint() {
    let app = create_test_app().await;
    
    let response = app
        .oneshot(
            Request::builder()
                .uri("/health")
                .body(Body::empty())
                .unwrap()
        )
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::OK);
    
    let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    
    assert_eq!(json["status"], "healthy");
}

// 데이터베이스와 함께 테스트
#[sqlx::test]
async fn test_user_creation(pool: PgPool) {
    let app = create_app_with_db(pool).await;
    
    let response = app
        .oneshot(
            Request::builder()
                .method("POST")
                .uri("/users")
                .header("content-type", "application/json")
                .body(Body::from(json!({
                    "name": "Test User",
                    "email": "test@example.com"
                }).to_string()))
                .unwrap()
        )
        .await
        .unwrap();
    
    assert_eq!(response.status(), StatusCode::CREATED);
}
```

## 테스트 더블 - 모킹과 스터빙

### Mockall을 사용한 모킹
```rust
use mockall::*;

// 트레이트 정의
#[automock]
pub trait Database {
    async fn get_user(&self, id: u64) -> Result<User, DbError>;
    async fn save_user(&self, user: &User) -> Result<(), DbError>;
}

// 프로덕션 구현
pub struct PostgresDb {
    pool: PgPool,
}

impl Database for PostgresDb {
    async fn get_user(&self, id: u64) -> Result<User, DbError> {
        // 실제 데이터베이스 쿼리
        sqlx::query_as("SELECT * FROM users WHERE id = $1")
            .bind(id)
            .fetch_one(&self.pool)
            .await
            .map_err(Into::into)
    }
    
    async fn save_user(&self, user: &User) -> Result<(), DbError> {
        // 실제 저장 로직
        Ok(())
    }
}

// 테스트에서 모킹 사용
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_user_service() {
        let mut mock_db = MockDatabase::new();
        
        // 기대값 설정
        mock_db
            .expect_get_user()
            .with(eq(42))
            .times(1)
            .returning(|_| Ok(User {
                id: 42,
                name: "Test".to_string(),
            }));
        
        let service = UserService::new(Box::new(mock_db));
        let user = service.find_user(42).await.unwrap();
        
        assert_eq!(user.name, "Test");
    }
}
```

### 수동 테스트 더블
```rust
// 페이크 구현
pub struct FakeDatabase {
    users: std::sync::Arc<std::sync::RwLock<HashMap<u64, User>>>,
}

impl FakeDatabase {
    pub fn new() -> Self {
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub fn with_users(users: Vec<User>) -> Self {
        let map = users.into_iter()
            .map(|u| (u.id, u))
            .collect();
        Self {
            users: Arc::new(RwLock::new(map)),
        }
    }
}

#[async_trait]
impl Database for FakeDatabase {
    async fn get_user(&self, id: u64) -> Result<User, DbError> {
        self.users
            .read()
            .unwrap()
            .get(&id)
            .cloned()
            .ok_or(DbError::NotFound)
    }
    
    async fn save_user(&self, user: &User) -> Result<(), DbError> {
        self.users
            .write()
            .unwrap()
            .insert(user.id, user.clone());
        Ok(())
    }
}
```

## 속성 기반 테스트 - Property Based Testing

### Proptest 사용
```rust
use proptest::prelude::*;

// 속성 정의
proptest! {
    #[test]
    fn test_add_commutative(a: i32, b: i32) {
        // 덧셈의 교환법칙
        assert_eq!(Calculator::add(a, b), Calculator::add(b, a));
    }
    
    #[test]
    fn test_add_associative(a: i32, b: i32, c: i32) {
        // 덧셈의 결합법칙
        let result1 = Calculator::add(Calculator::add(a, b)?, c);
        let result2 = Calculator::add(a, Calculator::add(b, c)?);
        prop_assert_eq!(result1, result2);
    }
    
    #[test]
    fn test_parse_serialize_roundtrip(
        s in "[a-zA-Z0-9]{1,100}"
    ) {
        // 파싱과 직렬화가 원본을 유지
        let parsed = MyType::parse(&s)?;
        let serialized = parsed.to_string();
        prop_assert_eq!(s, serialized);
    }
}

// 커스텀 전략
fn valid_email() -> impl Strategy<Value = String> {
    "[a-z]{1,10}@[a-z]{1,10}\\.[a-z]{2,4}"
}

proptest! {
    #[test]
    fn test_email_validation(email in valid_email()) {
        assert!(validate_email(&email).is_ok());
    }
}

// 상태 기계 테스팅
#[derive(Debug, Clone)]
enum Action {
    Insert(String, i32),
    Remove(String),
    Get(String),
}

proptest! {
    #[test]
    fn test_cache_model(
        actions in prop::collection::vec(action_strategy(), 0..100)
    ) {
        let mut cache = Cache::new();
        let mut model = HashMap::new();
        
        for action in actions {
            match action {
                Action::Insert(k, v) => {
                    cache.insert(k.clone(), v);
                    model.insert(k, v);
                }
                Action::Remove(k) => {
                    cache.remove(&k);
                    model.remove(&k);
                }
                Action::Get(k) => {
                    assert_eq!(cache.get(&k), model.get(&k));
                }
            }
        }
        
        // 최종 상태 일치 확인
        for (k, v) in &model {
            assert_eq!(cache.get(k), Some(v));
        }
    }
}
```

## 퍼징 - Fuzzing

### cargo-fuzz 사용
```rust
// fuzz/fuzz_targets/parser.rs
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        // 파서가 크래시하지 않는지 테스트
        let _ = my_parser::parse(s);
    }
});

// AFL++ 사용
#[cfg(fuzzing)]
fn main() {
    afl::fuzz!(|data: &[u8]| {
        if let Ok(input) = String::from_utf8(data.to_vec()) {
            let _ = process_input(&input);
        }
    });
}
```

## 스냅샷 테스팅

### insta 사용
```rust
use insta::assert_snapshot;

#[test]
fn test_render_template() {
    let template = Template::new("Hello, {{name}}!");
    let result = template.render(&json!({
        "name": "World"
    }));
    
    // 스냅샷과 비교
    assert_snapshot!(result);
}

#[test]
fn test_api_response() {
    let response = get_user_response(42);
    
    // JSON 스냅샷
    assert_json_snapshot!(response, {
        ".timestamp" => "[timestamp]",  // 동적 필드 마스킹
        ".**.id" => "[id]"
    });
}

// 인라인 스냅샷
#[test]
fn test_inline() {
    let result = format_message("test");
    assert_snapshot!(result, @r###"
    Message: test
    Timestamp: [filtered]
    "###);
}
```

## 벤치마크 테스팅

### Criterion 사용
```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 | 1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn bench_fibonacci(c: &mut Criterion) {
    let mut group = c.benchmark_group("fibonacci");
    
    for i in [20, 30, 35].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(i), i, |b, &i| {
            b.iter(|| fibonacci(black_box(i)));
        });
    }
    
    group.finish();
}

// 비교 벤치마크
fn bench_sorting(c: &mut Criterion) {
    let mut group = c.benchmark_group("sorting");
    
    let data: Vec<i32> = (0..1000).rev().collect();
    
    group.bench_function("std_sort", |b| {
        b.iter_batched(
            || data.clone(),
            |mut data| data.sort(),
            criterion::BatchSize::SmallInput,
        );
    });
    
    group.bench_function("quicksort", |b| {
        b.iter_batched(
            || data.clone(),
            |mut data| quicksort(&mut data),
            criterion::BatchSize::SmallInput,
        );
    });
    
    group.finish();
}

criterion_group!(benches, bench_fibonacci, bench_sorting);
criterion_main!(benches);
```

## 비동기 테스팅

### Tokio 테스트
```rust
#[tokio::test]
async fn test_async_function() {
    let result = async_operation().await;
    assert_eq!(result, 42);
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_concurrent_operations() {
    let (tx, mut rx) = tokio::sync::mpsc::channel(10);
    
    tokio::spawn(async move {
        tx.send(1).await.unwrap();
    });
    
    assert_eq!(rx.recv().await, Some(1));
}

// 타임아웃 테스트
#[tokio::test]
async fn test_with_timeout() {
    use tokio::time::{timeout, Duration};
    
    let result = timeout(
        Duration::from_secs(1),
        slow_operation()
    ).await;
    
    assert!(result.is_err(), "Operation should timeout");
}

// 시간 조작
#[tokio::test]
async fn test_with_time_manipulation() {
    tokio::time::pause();
    
    let start = tokio::time::Instant::now();
    
    let handle = tokio::spawn(async {
        tokio::time::sleep(Duration::from_secs(10)).await;
        "done"
    });
    
    // 시간을 10초 앞으로
    tokio::time::advance(Duration::from_secs(10)).await;
    
    let result = handle.await.unwrap();
    assert_eq!(result, "done");
    
    // 실제로는 거의 시간이 지나지 않음
    assert!(start.elapsed() < Duration::from_millis(100));
}
```

## E2E 테스팅

### Playwright/Selenium 통합
```rust
use thirtyfour::prelude::*;

#[tokio::test]
async fn test_full_user_journey() -> WebDriverResult<()> {
    let caps = DesiredCapabilities::chrome();
    let driver = WebDriver::new("http://localhost:9515", caps).await?;
    
    // 애플리케이션 시작
    let app_handle = start_test_app().await;
    
    // 홈페이지 방문
    driver.goto("http://localhost:3000").await?;
    
    // 로그인
    driver.find(By::Id("username")).await?.send_keys("test@example.com").await?;
    driver.find(By::Id("password")).await?.send_keys("password123").await?;
    driver.find(By::Id("login-button")).await?.click().await?;
    
    // 대시보드 확인
    let welcome = driver.find(By::ClassName("welcome-message")).await?;
    assert!(welcome.text().await?.contains("Welcome"));
    
    // 정리
    driver.quit().await?;
    app_handle.shutdown().await;
    
    Ok(())
}
```

## 테스트 커버리지

### tarpaulin 설정
```toml
# tarpaulin.toml
[default]
workspace = true
all-features = true
engine = "llvm"
exclude-files = ["*/tests/*", "*/benches/*"]
ignore-panics = true
timeout = "300s"
```

```bash
# 커버리지 실행
cargo tarpaulin --out Html --output-dir coverage

# CI/CD 통합
cargo tarpaulin --out Lcov --output-dir coverage
```

## CI/CD 통합

### GitHub Actions
```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
    
    - name: Cache
      uses: Swatinem/rust-cache@v2
    
    - name: Check formatting
      run: cargo fmt -- --check
    
    - name: Clippy
      run: cargo clippy -- -D warnings
    
    - name: Run tests
      run: cargo test --all-features
      env:
        DATABASE_URL: postgres://postgres:postgres@localhost/test
    
    - name: Run integration tests
      run: cargo test --test '*' --all-features
    
    - name: Coverage
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
```

## 테스트 전략 체크리스트

```rust
pub struct TestingStrategy {
    pub unit_tests: bool,
    pub integration_tests: bool,
    pub property_tests: bool,
    pub benchmarks: bool,
    pub fuzz_tests: bool,
    pub e2e_tests: bool,
    pub coverage_target: f32,
}

impl TestingStrategy {
    pub fn for_library() -> Self {
        Self {
            unit_tests: true,
            integration_tests: true,
            property_tests: true,
            benchmarks: true,
            fuzz_tests: false,
            e2e_tests: false,
            coverage_target: 80.0,
        }
    }
    
    pub fn for_web_service() -> Self {
        Self {
            unit_tests: true,
            integration_tests: true,
            property_tests: false,
            benchmarks: true,
            fuzz_tests: true,
            e2e_tests: true,
            coverage_target: 70.0,
        }
    }
    
    pub fn for_cli_tool() -> Self {
        Self {
            unit_tests: true,
            integration_tests: true,
            property_tests: false,
            benchmarks: false,
            fuzz_tests: false,
            e2e_tests: true,
            coverage_target: 60.0,
        }
    }
}
```

## 마무리: 테스팅의 균형

좋은 테스트의 특징:
1. **빠름**: 자주 실행할 수 있도록
2. **독립적**: 다른 테스트에 영향받지 않음
3. **반복 가능**: 같은 결과를 보장
4. **자기 검증**: 수동 검사 불필요
5. **시의적절**: 실패 시 빠른 피드백

기억하세요: 100% 커버리지보다 중요한 건 의미 있는 테스트.

---

## Connections
→ [[L6_ecosystem]] - 테스팅 도구 생태계
→ [[L8_production]] - 프로덕션 배포
← [[L5_real_projects]] - 실전 프로젝트
← [[L4.5_async_runtime]] - 비동기 런타임

---

Level: L5.5 (중급 심화)
Date: 2025-08-15
Tags: #rust #testing #tdd #property-testing #fuzzing #2025
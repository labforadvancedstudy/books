# L2-03: Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ Í∏∞Îä•
## CloudKit Í≥µÏú†, Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî, ÌåÄ ÌòëÏóÖ

---

> **"Great things in business are never done by one person."**

CloudKitÏùÑ ÌôúÏö©Ìïú Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ ÏãúÏä§ÌÖúÏúºÎ°ú ÌåÄ ÏÉùÏÇ∞ÏÑ±ÏùÑ Í∑πÎåÄÌôîÌï©ÎãàÎã§.

---

## üéØ Î™©Ìëú

**ÏôÑÏÑ± ÌõÑ Í≤∞Í≥ºÎ¨º**:
- Ïã§ÏãúÍ∞Ñ ÏûëÏóÖ Í≥µÏú†
- ÌåÄ Î©§Î≤Ñ Ï¥àÎåÄ
- Í≥µÎèô Ìé∏Ïßë
- ÌôúÎèô ÌîºÎìú
- ÎåìÍ∏Ä ÏãúÏä§ÌÖú

---

## üöÄ ÌòëÏóÖ ÏãúÏä§ÌÖú Íµ¨ÌòÑ

### 1Îã®Í≥Ñ: ÌåÄ ÌîÑÎ°úÏ†ùÌä∏ Í¥ÄÎ¶¨

**Presentation/Views/Collaboration/TeamProjectView.swift**:

```swift
import SwiftUI
import CloudKit
import Combine

struct TeamProjectView: View {
    @StateObject private var viewModel = TeamProjectViewModel()
    @State private var showingInviteSheet = false
    @State private var showingActivityFeed = false
    @State private var selectedMember: TeamMember?
    @State private var showingVideoCall = false
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 20) {
                    // ÌîÑÎ°úÏ†ùÌä∏ Ìó§Îçî
                    ProjectHeaderCard(project: viewModel.project)
                        .padding(.horizontal)
                    
                    // ÌåÄ Î©§Î≤Ñ
                    TeamMembersSection(
                        members: viewModel.teamMembers,
                        onMemberTap: { member in
                            selectedMember = member
                        },
                        onInvite: {
                            showingInviteSheet = true
                        }
                    )
                    .padding(.horizontal)
                    
                    // Ïã§ÏãúÍ∞Ñ ÌôúÎèô Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
                    if !viewModel.activeUsers.isEmpty {
                        ActiveUsersBar(users: viewModel.activeUsers)
                            .padding(.horizontal)
                    }
                    
                    // ÏßÑÌñâÎ•† ÎåÄÏãúÎ≥¥Îìú
                    ProgressDashboard(
                        totalTasks: viewModel.totalTasks,
                        completedTasks: viewModel.completedTasks,
                        overdueCount: viewModel.overdueTasks,
                        todayCount: viewModel.todayTasks
                    )
                    .padding(.horizontal)
                    
                    // Í≥µÏú† ÏûëÏóÖ Î™©Î°ù
                    SharedTasksSection(
                        tasks: viewModel.sharedTasks,
                        currentUserId: viewModel.currentUserId,
                        onTaskUpdate: { task in
                            Task {
                                await viewModel.updateSharedTask(task)
                            }
                        },
                        onAssignUser: { task, userId in
                            Task {
                                await viewModel.assignTask(task, to: userId)
                            }
                        }
                    )
                    
                    // ÏµúÍ∑º ÌôúÎèô
                    RecentActivitySection(activities: viewModel.recentActivities)
                        .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle(viewModel.project.name)
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button {
                            showingActivityFeed = true
                        } label: {
                            Label("ÌôúÎèô ÌîºÎìú", systemImage: "list.bullet.rectangle")
                        }
                        
                        Button {
                            showingVideoCall = true
                        } label: {
                            Label("ÌôîÏÉÅ ÌöåÏùò", systemImage: "video")
                        }
                        
                        Divider()
                        
                        Button {
                            Task {
                                await viewModel.exportProject()
                            }
                        } label: {
                            Label("ÎÇ¥Î≥¥ÎÇ¥Í∏∞", systemImage: "square.and.arrow.up")
                        }
                        
                        Button(role: .destructive) {
                            Task {
                                await viewModel.leaveProject()
                            }
                        } label: {
                            Label("ÌîÑÎ°úÏ†ùÌä∏ ÎÇòÍ∞ÄÍ∏∞", systemImage: "person.crop.circle.badge.minus")
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                    }
                }
            }
            .sheet(isPresented: $showingInviteSheet) {
                InviteMembersView(project: viewModel.project)
            }
            .sheet(isPresented: $showingActivityFeed) {
                ActivityFeedView(projectId: viewModel.project.id)
            }
            .sheet(item: $selectedMember) { member in
                MemberDetailView(member: member, project: viewModel.project)
            }
            .sheet(isPresented: $showingVideoCall) {
                VideoCallView(project: viewModel.project)
            }
            .refreshable {
                await viewModel.refresh()
            }
            .onAppear {
                Task {
                    await viewModel.startRealTimeSync()
                }
            }
            .onDisappear {
                viewModel.stopRealTimeSync()
            }
        }
    }
}

// MARK: - Supporting Views

struct ProjectHeaderCard: View {
    let project: Project
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: project.icon)
                    .font(.title)
                    .foregroundColor(.white)
                    .frame(width: 50, height: 50)
                    .background(Color(project.color))
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(project.name)
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    if let description = project.description {
                        Text(description)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .lineLimit(2)
                    }
                }
                
                Spacer()
                
                // Í≥µÏú† ÏÉÅÌÉú
                Image(systemName: "icloud.and.arrow.up.fill")
                    .foregroundColor(.green)
            }
            
            // ÏßÑÌñâÎ•† Î∞î
            ProgressView(value: project.progressPercentage / 100)
                .tint(Color(project.color))
            
            Text("\(Int(project.progressPercentage))% ÏôÑÎ£å")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.1), radius: 5)
    }
}

struct TeamMembersSection: View {
    let members: [TeamMember]
    let onMemberTap: (TeamMember) -> Void
    let onInvite: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("ÌåÄ Î©§Î≤Ñ")
                    .font(.headline)
                
                Spacer()
                
                Button(action: onInvite) {
                    Image(systemName: "person.badge.plus")
                        .foregroundColor(.blue)
                }
            }
            
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(members) { member in
                        MemberCard(member: member) {
                            onMemberTap(member)
                        }
                    }
                    
                    // Ï¥àÎåÄ Î≤ÑÌäº
                    Button(action: onInvite) {
                        VStack {
                            Image(systemName: "plus.circle.fill")
                                .font(.title)
                                .foregroundColor(.blue)
                            
                            Text("Ï¥àÎåÄ")
                                .font(.caption)
                                .foregroundColor(.blue)
                        }
                        .frame(width: 70, height: 90)
                        .background(Color.blue.opacity(0.1))
                        .cornerRadius(12)
                    }
                }
            }
        }
    }
}

struct MemberCard: View {
    let member: TeamMember
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ
                if let avatarURL = member.avatarURL {
                    AsyncImage(url: avatarURL) { image in
                        image
                            .resizable()
                            .scaledToFill()
                    } placeholder: {
                        Image(systemName: "person.fill")
                            .foregroundColor(.white)
                            .frame(width: 30, height: 30)
                    }
                    .frame(width: 50, height: 50)
                    .clipShape(Circle())
                } else {
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 50, height: 50)
                        .overlay(
                            Text(member.initials)
                                .foregroundColor(.white)
                                .fontWeight(.semibold)
                        )
                }
                
                // Ïò®ÎùºÏù∏ ÏÉÅÌÉú ÌëúÏãú
                if member.isOnline {
                    Circle()
                        .fill(Color.green)
                        .frame(width: 12, height: 12)
                        .offset(x: 20, y: -55)
                }
                
                Text(member.name)
                    .font(.caption)
                    .lineLimit(1)
                
                Text(member.role.title)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
            .frame(width: 70, height: 90)
            .background(Color(.secondarySystemBackground))
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct ActiveUsersBar: View {
    let users: [TeamMember]
    
    var body: some View {
        HStack {
            Image(systemName: "circle.fill")
                .foregroundColor(.green)
                .font(.caption)
            
            Text("\(users.count)Î™ÖÏù¥ Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏûëÏóÖ Ï§ë")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Spacer()
            
            // ÌôúÏÑ± ÏÇ¨Ïö©Ïûê ÏïÑÎ∞îÌÉÄ
            HStack(spacing: -10) {
                ForEach(users.prefix(3)) { user in
                    Circle()
                        .fill(Color.blue)
                        .frame(width: 24, height: 24)
                        .overlay(
                            Text(user.initials)
                                .font(.caption2)
                                .foregroundColor(.white)
                        )
                        .overlay(
                            Circle()
                                .stroke(Color(.systemBackground), lineWidth: 2)
                        )
                }
                
                if users.count > 3 {
                    Circle()
                        .fill(Color.gray)
                        .frame(width: 24, height: 24)
                        .overlay(
                            Text("+\(users.count - 3)")
                                .font(.caption2)
                                .foregroundColor(.white)
                        )
                }
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color.green.opacity(0.1))
        .cornerRadius(8)
    }
}

struct SharedTasksSection: View {
    let tasks: [SharedTask]
    let currentUserId: String
    let onTaskUpdate: (SharedTask) -> Void
    let onAssignUser: (SharedTask, String) -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Í≥µÏú† ÏûëÏóÖ")
                .font(.headline)
                .padding(.horizontal)
            
            ForEach(tasks) { task in
                SharedTaskRow(
                    task: task,
                    currentUserId: currentUserId,
                    onUpdate: onTaskUpdate,
                    onAssign: onAssignUser
                )
            }
        }
    }
}

struct SharedTaskRow: View {
    let task: SharedTask
    let currentUserId: String
    let onUpdate: (SharedTask) -> Void
    let onAssign: (SharedTask, String) -> Void
    
    @State private var isExpanded = false
    @State private var showingComments = false
    @State private var showingAssignSheet = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            HStack {
                // ÏôÑÎ£å Ï≤¥ÌÅ¨Î∞ïÏä§
                Button {
                    var updatedTask = task
                    updatedTask.isCompleted.toggle()
                    onUpdate(updatedTask)
                } label: {
                    Image(systemName: task.isCompleted ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(task.isCompleted ? .green : .gray)
                        .font(.title3)
                }
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(task.title)
                        .strikethrough(task.isCompleted)
                        .foregroundColor(task.isCompleted ? .secondary : .primary)
                    
                    HStack(spacing: 8) {
                        // Îã¥ÎãπÏûê
                        if let assignee = task.assignee {
                            HStack(spacing: 4) {
                                Image(systemName: "person.fill")
                                    .font(.caption2)
                                Text(assignee.name)
                                    .font(.caption)
                            }
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.blue.opacity(0.1))
                            .cornerRadius(4)
                        }
                        
                        // ÎßàÍ∞êÏùº
                        if let dueDate = task.dueDate {
                            HStack(spacing: 4) {
                                Image(systemName: "calendar")
                                    .font(.caption2)
                                Text(dueDate, style: .date)
                                    .font(.caption)
                            }
                            .foregroundColor(task.isOverdue ? .red : .secondary)
                        }
                        
                        // ÎåìÍ∏Ä Ïàò
                        if task.commentCount > 0 {
                            HStack(spacing: 4) {
                                Image(systemName: "bubble.left")
                                    .font(.caption2)
                                Text("\(task.commentCount)")
                                    .font(.caption)
                            }
                            .foregroundColor(.secondary)
                        }
                    }
                }
                
                Spacer()
                
                // Ïã§ÏãúÍ∞Ñ Ìé∏Ïßë Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
                if let editor = task.currentEditor, editor.id != currentUserId {
                    HStack(spacing: 4) {
                        Circle()
                            .fill(Color.orange)
                            .frame(width: 8, height: 8)
                        Text("\(editor.name) Ìé∏Ïßë Ï§ë")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                }
                
                // ÎçîÎ≥¥Í∏∞ Î≤ÑÌäº
                Button {
                    withAnimation {
                        isExpanded.toggle()
                    }
                } label: {
                    Image(systemName: "chevron.down")
                        .rotationEffect(.degrees(isExpanded ? 180 : 0))
                        .foregroundColor(.secondary)
                }
            }
            .padding()
            .background(Color(.secondarySystemBackground))
            
            // ÌôïÏû•Îêú ÎÇ¥Ïö©
            if isExpanded {
                VStack(alignment: .leading, spacing: 12) {
                    if let description = task.description {
                        Text(description)
                            .font(.caption)
                            .foregroundColor(.secondary)
                            .padding(.horizontal)
                    }
                    
                    HStack(spacing: 16) {
                        Button {
                            showingAssignSheet = true
                        } label: {
                            Label("Îã¥ÎãπÏûê ÏßÄÏ†ï", systemImage: "person.badge.plus")
                                .font(.caption)
                        }
                        
                        Button {
                            showingComments = true
                        } label: {
                            Label("ÎåìÍ∏Ä", systemImage: "bubble.left")
                                .font(.caption)
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal)
                    .padding(.bottom, 8)
                }
                .background(Color(.tertiarySystemBackground))
            }
        }
        .cornerRadius(12)
        .padding(.horizontal)
        .sheet(isPresented: $showingComments) {
            CommentsView(task: task)
        }
        .sheet(isPresented: $showingAssignSheet) {
            AssignMemberSheet(task: task, onAssign: { userId in
                onAssign(task, userId)
            })
        }
    }
}
```

### 2Îã®Í≥Ñ: CloudKit Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî

**Services/RealtimeSync/CloudKitSyncManager.swift**:

```swift
import CloudKit
import Combine

class CloudKitSyncManager: ObservableObject {
    private let container: CKContainer
    private let privateDatabase: CKDatabase
    private let sharedDatabase: CKDatabase
    
    @Published var syncStatus: SyncStatus = .idle
    @Published var lastSyncDate: Date?
    @Published var conflictedRecords: [CKRecord] = []
    
    private var subscriptions: Set<AnyCancellable> = []
    private var changeToken: CKServerChangeToken?
    private var syncTimer: Timer?
    
    init() {
        container = CKContainer(identifier: "iCloud.com.yourapp.taskmaster")
        privateDatabase = container.privateCloudDatabase
        sharedDatabase = container.sharedCloudDatabase
        
        setupSubscriptions()
        startAutoSync()
    }
    
    // MARK: - Real-time Subscriptions
    
    private func setupSubscriptions() {
        // ÏûëÏóÖ Î≥ÄÍ≤Ω Íµ¨ÎèÖ
        let taskSubscription = CKDatabaseSubscription(subscriptionID: "task-changes")
        
        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        notificationInfo.shouldSendMutableContent = true
        taskSubscription.notificationInfo = notificationInfo
        
        privateDatabase.save(taskSubscription) { subscription, error in
            if let error = error {
                print("Íµ¨ÎèÖ ÏÑ§Ï†ï Ïã§Ìå®: \(error)")
            } else {
                print("Íµ¨ÎèÖ ÏÑ§Ï†ï ÏÑ±Í≥µ")
                self.listenForChanges()
            }
        }
    }
    
    private func listenForChanges() {
        // Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Í∞êÏßÄ
        let operation = CKFetchDatabaseChangesOperation(previousServerChangeToken: changeToken)
        
        operation.recordZoneWithIDChangedBlock = { zoneID in
            self.fetchChanges(in: zoneID)
        }
        
        operation.recordZoneWithIDWasDeletedBlock = { zoneID in
            self.handleDeletedZone(zoneID)
        }
        
        operation.changeTokenUpdatedBlock = { token in
            self.changeToken = token
            self.saveChangeToken(token)
        }
        
        operation.fetchDatabaseChangesResultBlock = { result in
            switch result {
            case .success(let token):
                self.changeToken = token
                self.saveChangeToken(token)
                self.syncStatus = .synced
                self.lastSyncDate = Date()
                
            case .failure(let error):
                self.syncStatus = .error(error)
                print("Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: \(error)")
            }
        }
        
        privateDatabase.add(operation)
    }
    
    private func fetchChanges(in zoneID: CKRecordZone.ID) {
        let configuration = CKFetchRecordZoneChangesOperation.ZoneConfiguration()
        configuration.previousServerChangeToken = loadZoneChangeToken(for: zoneID)
        
        let operation = CKFetchRecordZoneChangesOperation(
            recordZoneIDs: [zoneID],
            configurationsByRecordZoneID: [zoneID: configuration]
        )
        
        var changedRecords: [CKRecord] = []
        var deletedRecordIDs: [CKRecord.ID] = []
        
        operation.recordWasChangedBlock = { recordID, result in
            switch result {
            case .success(let record):
                changedRecords.append(record)
            case .failure(let error):
                print("Î†àÏΩîÎìú Î≥ÄÍ≤Ω Ï≤òÎ¶¨ Ïã§Ìå®: \(error)")
            }
        }
        
        operation.recordWithIDWasDeletedBlock = { recordID, recordType in
            deletedRecordIDs.append(recordID)
        }
        
        operation.recordZoneFetchResultBlock = { zoneID, result in
            switch result {
            case .success(let (token, _, _)):
                self.saveZoneChangeToken(token, for: zoneID)
                
                // Î°úÏª¨ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
                Task {
                    await self.updateLocalDatabase(
                        changed: changedRecords,
                        deleted: deletedRecordIDs
                    )
                }
                
            case .failure(let error):
                print("Zone Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: \(error)")
            }
        }
        
        privateDatabase.add(operation)
    }
    
    // MARK: - Conflict Resolution
    
    func resolveConflicts(_ conflicts: [CKRecord]) async {
        for conflict in conflicts {
            await resolveConflict(conflict)
        }
    }
    
    private func resolveConflict(_ serverRecord: CKRecord) async {
        // Ï∂©Îèå Ìï¥Í≤∞ Ï†ÑÎûµ: ÏµúÏã† ÏóÖÎç∞Ïù¥Ìä∏ Ïö∞ÏÑ†
        guard let localRecord = await fetchLocalRecord(with: serverRecord.recordID) else {
            // Î°úÏª¨ Î†àÏΩîÎìúÍ∞Ä ÏóÜÏúºÎ©¥ ÏÑúÎ≤Ñ Î†àÏΩîÎìú ÏÇ¨Ïö©
            await saveToLocal(serverRecord)
            return
        }
        
        let serverModified = serverRecord.modificationDate ?? Date.distantPast
        let localModified = localRecord.modificationDate ?? Date.distantPast
        
        if serverModified > localModified {
            // ÏÑúÎ≤ÑÍ∞Ä Îçî ÏµúÏã†
            await saveToLocal(serverRecord)
        } else if localModified > serverModified {
            // Î°úÏª¨Ïù¥ Îçî ÏµúÏã†
            await uploadToServer(localRecord)
        } else {
            // Î≥ëÌï© ÌïÑÏöî
            let mergedRecord = await mergeRecords(local: localRecord, server: serverRecord)
            await saveToLocal(mergedRecord)
            await uploadToServer(mergedRecord)
        }
    }
    
    private func mergeRecords(local: CKRecord, server: CKRecord) async -> CKRecord {
        let merged = CKRecord(recordType: local.recordType, recordID: local.recordID)
        
        // Í∞Å ÌïÑÎìúÎ≥ÑÎ°ú Î≥ëÌï© Ï†ÑÎûµ Ï†ÅÏö©
        for key in local.allKeys() {
            if let localValue = local[key],
               let serverValue = server[key] {
                // ÌïÑÎìúÎ≥Ñ Î≥ëÌï© Î°úÏßÅ
                merged[key] = mergeField(
                    key: key,
                    localValue: localValue,
                    serverValue: serverValue
                )
            }
        }
        
        return merged
    }
    
    private func mergeField(key: String, localValue: CKRecordValue, serverValue: CKRecordValue) -> CKRecordValue {
        // ÌïÑÎìúÎ≥Ñ Ïª§Ïä§ÌÖÄ Î≥ëÌï© Î°úÏßÅ
        switch key {
        case "title", "description":
            // ÌÖçÏä§Ìä∏ ÌïÑÎìú: Îçî Í∏¥ Í∞í ÏÇ¨Ïö©
            if let localString = localValue as? String,
               let serverString = serverValue as? String {
                return localString.count > serverString.count ? localString : serverString
            }
            
        case "isCompleted":
            // ÏôÑÎ£å ÏÉÅÌÉú: true Ïö∞ÏÑ†
            if let localBool = localValue as? Bool,
               let serverBool = serverValue as? Bool {
                return localBool || serverBool ? true : false
            }
            
        case "tags":
            // Î∞∞Ïó¥: Ìï©ÏßëÌï©
            if let localArray = localValue as? [String],
               let serverArray = serverValue as? [String] {
                return Array(Set(localArray + serverArray)) as CKRecordValue
            }
            
        default:
            // Í∏∞Î≥∏: ÏÑúÎ≤Ñ Í∞í ÏÇ¨Ïö©
            return serverValue
        }
        
        return serverValue
    }
    
    // MARK: - Auto Sync
    
    private func startAutoSync() {
        syncTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { _ in
            Task {
                await self.performSync()
            }
        }
    }
    
    func performSync() async {
        syncStatus = .syncing
        
        do {
            // 1. Î°úÏª¨ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏóÖÎ°úÎìú
            let localChanges = await fetchLocalChanges()
            try await uploadChanges(localChanges)
            
            // 2. ÏÑúÎ≤Ñ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Îã§Ïö¥Î°úÎìú
            listenForChanges()
            
            // 3. Ï∂©Îèå Ìï¥Í≤∞
            if !conflictedRecords.isEmpty {
                await resolveConflicts(conflictedRecords)
                conflictedRecords.removeAll()
            }
            
            syncStatus = .synced
            lastSyncDate = Date()
            
        } catch {
            syncStatus = .error(error)
        }
    }
    
    // MARK: - Sharing
    
    func shareRecord(_ record: CKRecord, with users: [String]) async throws -> CKShare {
        let share = CKShare(rootRecord: record)
        share[CKShare.SystemFieldKey.title] = "Í≥µÏú† ÏûëÏóÖ" as CKRecordValue
        share[CKShare.SystemFieldKey.shareType] = "com.yourapp.task" as CKRecordValue
        
        // Ï∞∏Í∞ÄÏûê Ï∂îÍ∞Ä
        for email in users {
            let lookupInfo = CKUserIdentity.LookupInfo(emailAddress: email)
            
            if let userIdentity = try await container.discoverUserIdentity(with: lookupInfo) {
                let participant = CKShare.Participant(
                    userIdentity: userIdentity,
                    permission: .readWrite,
                    role: .privateUser,
                    acceptanceStatus: .pending
                )
                share.addParticipant(participant)
            }
        }
        
        // CloudKitÏóê Ï†ÄÏû•
        let operation = CKModifyRecordsOperation(
            recordsToSave: [record, share],
            recordIDsToDelete: nil
        )
        
        return try await withCheckedThrowingContinuation { continuation in
            operation.modifyRecordsResultBlock = { result in
                switch result {
                case .success:
                    continuation.resume(returning: share)
                case .failure(let error):
                    continuation.resume(throwing: error)
                }
            }
            
            sharedDatabase.add(operation)
        }
    }
    
    // MARK: - Helper Methods
    
    private func saveChangeToken(_ token: CKServerChangeToken) {
        if let data = try? NSKeyedArchiver.archivedData(
            withRootObject: token,
            requiringSecureCoding: false
        ) {
            UserDefaults.standard.set(data, forKey: "DatabaseChangeToken")
        }
    }
    
    private func loadChangeToken() -> CKServerChangeToken? {
        guard let data = UserDefaults.standard.data(forKey: "DatabaseChangeToken") else {
            return nil
        }
        
        return try? NSKeyedUnarchiver.unarchivedObject(
            ofClass: CKServerChangeToken.self,
            from: data
        )
    }
    
    private func saveZoneChangeToken(_ token: CKServerChangeToken, for zoneID: CKRecordZone.ID) {
        if let data = try? NSKeyedArchiver.archivedData(
            withRootObject: token,
            requiringSecureCoding: false
        ) {
            UserDefaults.standard.set(data, forKey: "ZoneChangeToken-\(zoneID.zoneName)")
        }
    }
    
    private func loadZoneChangeToken(for zoneID: CKRecordZone.ID) -> CKServerChangeToken? {
        guard let data = UserDefaults.standard.data(forKey: "ZoneChangeToken-\(zoneID.zoneName)") else {
            return nil
        }
        
        return try? NSKeyedUnarchiver.unarchivedObject(
            ofClass: CKServerChangeToken.self,
            from: data
        )
    }
}

// MARK: - Supporting Types

enum SyncStatus: Equatable {
    case idle
    case syncing
    case synced
    case error(Error)
    
    static func == (lhs: SyncStatus, rhs: SyncStatus) -> Bool {
        switch (lhs, rhs) {
        case (.idle, .idle), (.syncing, .syncing), (.synced, .synced):
            return true
        case (.error, .error):
            return true
        default:
            return false
        }
    }
}
```

### 3Îã®Í≥Ñ: ÎåìÍ∏Ä ÏãúÏä§ÌÖú

**Presentation/Views/Collaboration/CommentsView.swift**:

```swift
import SwiftUI

struct CommentsView: View {
    let task: SharedTask
    @StateObject private var viewModel = CommentsViewModel()
    @State private var newComment = ""
    @State private var replyingTo: Comment?
    @State private var editingComment: Comment?
    @FocusState private var isInputFocused: Bool
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // ÎåìÍ∏Ä Î™©Î°ù
                if viewModel.comments.isEmpty {
                    EmptyCommentsView()
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                } else {
                    ScrollViewReader { proxy in
                        ScrollView {
                            LazyVStack(spacing: 12) {
                                ForEach(viewModel.comments) { comment in
                                    CommentRow(
                                        comment: comment,
                                        currentUserId: viewModel.currentUserId,
                                        onReply: { replyingTo = comment },
                                        onEdit: { editingComment = comment },
                                        onDelete: { 
                                            Task {
                                                await viewModel.deleteComment(comment)
                                            }
                                        },
                                        onReaction: { reaction in
                                            Task {
                                                await viewModel.addReaction(to: comment, reaction: reaction)
                                            }
                                        }
                                    )
                                    .id(comment.id)
                                }
                            }
                            .padding()
                        }
                        .onChange(of: viewModel.comments.count) { _ in
                            // ÏÉà ÎåìÍ∏ÄÏù¥ Ï∂îÍ∞ÄÎêòÎ©¥ Ïä§ÌÅ¨Î°§
                            if let lastComment = viewModel.comments.last {
                                withAnimation {
                                    proxy.scrollTo(lastComment.id, anchor: .bottom)
                                }
                            }
                        }
                    }
                }
                
                Divider()
                
                // ÏûÖÎ†• ÏòÅÏó≠
                CommentInputView(
                    text: $newComment,
                    replyingTo: replyingTo,
                    onSend: {
                        Task {
                            await sendComment()
                        }
                    },
                    onCancelReply: {
                        replyingTo = nil
                    }
                )
                .focused($isInputFocused)
                .padding()
                .background(Color(.systemBackground))
            }
            .navigationTitle("ÎåìÍ∏Ä")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Îã´Í∏∞") {
                        // Dismiss
                    }
                }
            }
            .task {
                await viewModel.loadComments(for: task.id)
                await viewModel.startListening()
            }
            .onDisappear {
                viewModel.stopListening()
            }
        }
    }
    
    private func sendComment() async {
        guard !newComment.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        let comment = Comment(
            id: UUID(),
            taskId: task.id,
            text: newComment,
            authorId: viewModel.currentUserId,
            authorName: viewModel.currentUserName,
            createdAt: Date(),
            replyToId: replyingTo?.id,
            mentions: extractMentions(from: newComment),
            attachments: []
        )
        
        await viewModel.addComment(comment)
        
        newComment = ""
        replyingTo = nil
        isInputFocused = false
        
        // ÌñÖÌã± ÌîºÎìúÎ∞±
        let impact = UIImpactFeedbackGenerator(style: .light)
        impact.impactOccurred()
    }
    
    private func extractMentions(from text: String) -> [String] {
        let pattern = "@(\\w+)"
        let regex = try? NSRegularExpression(pattern: pattern)
        let matches = regex?.matches(
            in: text,
            range: NSRange(location: 0, length: text.utf16.count)
        ) ?? []
        
        return matches.compactMap { match in
            if let range = Range(match.range(at: 1), in: text) {
                return String(text[range])
            }
            return nil
        }
    }
}

struct CommentRow: View {
    let comment: Comment
    let currentUserId: String
    let onReply: () -> Void
    let onEdit: () -> Void
    let onDelete: () -> Void
    let onReaction: (String) -> Void
    
    @State private var showingActions = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Ìó§Îçî
            HStack {
                // ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ
                Circle()
                    .fill(Color.blue)
                    .frame(width: 32, height: 32)
                    .overlay(
                        Text(comment.authorName.prefix(1))
                            .foregroundColor(.white)
                            .font(.caption)
                            .fontWeight(.semibold)
                    )
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(comment.authorName)
                        .font(.caption)
                        .fontWeight(.semibold)
                    
                    Text(comment.createdAt, style: .relative)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                if comment.authorId == currentUserId {
                    Menu {
                        Button {
                            onEdit()
                        } label: {
                            Label("Ìé∏Ïßë", systemImage: "pencil")
                        }
                        
                        Button(role: .destructive) {
                            onDelete()
                        } label: {
                            Label("ÏÇ≠Ï†ú", systemImage: "trash")
                        }
                    } label: {
                        Image(systemName: "ellipsis")
                            .foregroundColor(.secondary)
                            .font(.caption)
                    }
                }
            }
            
            // ÎãµÍ∏Ä ÌëúÏãú
            if let replyToId = comment.replyToId {
                HStack {
                    Image(systemName: "arrow.turn.down.right")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                    
                    Text("ÎãµÍ∏Ä")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .padding(.leading, 40)
            }
            
            // ÎåìÍ∏Ä ÎÇ¥Ïö©
            Text(comment.text)
                .font(.callout)
                .padding(.leading, comment.replyToId != nil ? 40 : 0)
            
            // Ï≤®Î∂Ä ÌååÏùº
            if !comment.attachments.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(comment.attachments) { attachment in
                            AttachmentPreview(attachment: attachment)
                        }
                    }
                }
                .padding(.leading, 40)
            }
            
            // Î∞òÏùë Î∞è Ïï°ÏÖò
            HStack(spacing: 16) {
                // Î∞òÏùë
                HStack(spacing: 8) {
                    ForEach(["üëç", "‚ù§Ô∏è", "üòÑ", "üéâ", "ü§î"], id: \.self) { emoji in
                        Button {
                            onReaction(emoji)
                        } label: {
                            Text(emoji)
                                .font(.caption)
                        }
                    }
                }
                
                Spacer()
                
                // ÎãµÍ∏Ä Î≤ÑÌäº
                Button {
                    onReply()
                } label: {
                    Label("ÎãµÍ∏Ä", systemImage: "bubble.left")
                        .font(.caption)
                        .foregroundColor(.blue)
                }
            }
            .padding(.leading, 40)
            
            // Î∞òÏùë ÌëúÏãú
            if !comment.reactions.isEmpty {
                HStack {
                    ForEach(Array(comment.reactions.keys), id: \.self) { reaction in
                        HStack(spacing: 2) {
                            Text(reaction)
                            Text("\(comment.reactions[reaction]?.count ?? 0)")
                                .font(.caption2)
                                .foregroundColor(.secondary)
                        }
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
                .padding(.leading, 40)
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
    }
}

struct CommentInputView: View {
    @Binding var text: String
    let replyingTo: Comment?
    let onSend: () -> Void
    let onCancelReply: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // ÎãµÍ∏Ä ÌëúÏãú
            if let replyingTo = replyingTo {
                HStack {
                    Image(systemName: "arrow.turn.down.right")
                        .font(.caption)
                    
                    Text("\(replyingTo.authorName)ÏóêÍ≤å ÎãµÍ∏Ä")
                        .font(.caption)
                    
                    Spacer()
                    
                    Button("Ï∑®ÏÜå") {
                        onCancelReply()
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(Color.blue.opacity(0.1))
                .cornerRadius(8)
            }
            
            // ÏûÖÎ†• ÌïÑÎìú
            HStack(alignment: .bottom) {
                TextField("ÎåìÍ∏Ä ÏûÖÎ†•...", text: $text, axis: .vertical)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .lineLimit(1...5)
                
                Button(action: onSend) {
                    Image(systemName: "paperplane.fill")
                        .foregroundColor(.white)
                        .frame(width: 36, height: 36)
                        .background(text.isEmpty ? Color.gray : Color.blue)
                        .clipShape(Circle())
                }
                .disabled(text.isEmpty)
            }
        }
    }
}
```

---

## üéØ Ïó¨Í∏∞ÏÑú Î∞∞Ïö¥ Í≤É

### 1. **CloudKit Í≥µÏú†**
- CKShare Íµ¨ÌòÑ
- Ï∞∏Í∞ÄÏûê Í¥ÄÎ¶¨
- Í∂åÌïú Ï†úÏñ¥
- Í≥µÏú† URL ÏÉùÏÑ±

### 2. **Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî**
- Î≥ÄÍ≤Ω Í∞êÏßÄ
- Ï∂©Îèå Ìï¥Í≤∞
- ÏûêÎèô Î≥ëÌï©
- Ïò§ÌîÑÎùºÏù∏ ÏßÄÏõê

### 3. **ÌòëÏóÖ UI/UX**
- Ïã§ÏãúÍ∞Ñ Ïù∏ÎîîÏºÄÏù¥ÌÑ∞
- ÎèôÏãú Ìé∏Ïßë ÌëúÏãú
- ÌôúÎèô ÌîºÎìú
- Î©òÏÖò ÏãúÏä§ÌÖú

### 4. **ÎåìÍ∏Ä ÏãúÏä§ÌÖú**
- Ïä§Î†àÎìú ÎåìÍ∏Ä
- Î∞òÏùë Í∏∞Îä•
- Î©òÏÖò ÏïåÎ¶º
- Ï≤®Î∂Ä ÌååÏùº

---

## üéâ ÏÑ±Í≥µ ÌôïÏù∏

**ÌòëÏóÖ Í∏∞Îä• Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏**:
- [ ] Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏûëÏóÖ ÎèôÍ∏∞Ìôî
- [ ] Ïó¨Îü¨ ÏÇ¨Ïö©ÏûêÍ∞Ä ÎèôÏãú Ìé∏Ïßë Í∞ÄÎä•
- [ ] Ï∂©Îèå ÏûêÎèô Ìï¥Í≤∞
- [ ] ÎåìÍ∏ÄÍ≥º Î∞òÏùë Ï∂îÍ∞Ä Í∞ÄÎä•
- [ ] ÌôúÎèô ÎÇ¥Ïó≠ Ï∂îÏ†Å

---

**ÏôÑÎ≤ΩÌï©ÎãàÎã§! Ïã§ÏãúÍ∞Ñ ÌòëÏóÖ ÏãúÏä§ÌÖúÏù¥ ÏôÑÏÑ±ÎêòÏóàÏäµÎãàÎã§.**
# L2-04: Siri Shortcuts & ÏúÑÏ†Ø
## App Intents, Live Activities, Interactive Widgets

---

> **"The best interface is no interface."**

SiriÏôÄ ÏúÑÏ†ØÏúºÎ°ú Ïï±ÏùÑ Î≤óÏñ¥ÎÇò ÏãúÏä§ÌÖú Ï†ÑÏ≤¥ÏóêÏÑú ÏûëÏóÖÏùÑ Í¥ÄÎ¶¨Ìï©ÎãàÎã§.

---

## üéØ Î™©Ìëú

**ÏôÑÏÑ± ÌõÑ Í≤∞Í≥ºÎ¨º**:
- Siri ÏùåÏÑ± Î™ÖÎ†π
- Ìôà ÌôîÎ©¥ ÏúÑÏ†Ø
- Ïû†Í∏à ÌôîÎ©¥ ÏúÑÏ†Ø
- Live Activities
- App Shortcuts

---

## üöÄ App Intents Íµ¨ÌòÑ

### 1Îã®Í≥Ñ: App Intent Ï†ïÏùò

**Intents/TaskIntents.swift**:

```swift
import AppIntents
import SwiftUI
import WidgetKit

// MARK: - ÏûëÏóÖ Ï∂îÍ∞Ä Intent

struct AddTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "ÏûëÏóÖ Ï∂îÍ∞Ä"
    static var description = IntentDescription("ÏÉàÎ°úÏö¥ ÏûëÏóÖÏùÑ Îπ†Î•¥Í≤å Ï∂îÍ∞ÄÌï©ÎãàÎã§")
    static var openAppWhenRun: Bool = false
    
    @Parameter(title: "Ï†úÎ™©", requestValueDialog: "Ïñ¥Îñ§ ÏûëÏóÖÏùÑ Ï∂îÍ∞ÄÌï†ÍπåÏöî?")
    var title: String
    
    @Parameter(title: "ÎßàÍ∞êÏùº", optionsProvider: DueDateOptionsProvider())
    var dueDate: DueDateOption?
    
    @Parameter(title: "Ïö∞ÏÑ†ÏàúÏúÑ", default: .medium)
    var priority: TaskPriority
    
    @Parameter(title: "ÌîÑÎ°úÏ†ùÌä∏")
    var project: ProjectEntity?
    
    @Parameter(title: "Î©îÎ™®")
    var notes: String?
    
    static var parameterSummary: some ParameterSummary {
        Summary("ÏûëÏóÖ \(\.$title) Ï∂îÍ∞Ä") {
            \.$dueDate
            \.$priority
            \.$project
            \.$notes
        }
    }
    
    func perform() async throws -> some IntentResult & ReturnsValue<TaskEntity> & ShowsSnippetView {
        let taskManager = TaskManager.shared
        
        let task = try await taskManager.createTask(
            title: title,
            dueDate: dueDate?.date,
            priority: priority.toPriority(),
            projectId: project?.id,
            notes: notes
        )
        
        // ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏
        WidgetCenter.shared.reloadAllTimelines()
        
        return .result(
            value: TaskEntity(from: task),
            view: TaskAddedView(task: task)
        )
    }
}

// MARK: - Ïò§Îäò Ìï† Ïùº Î≥¥Í∏∞

struct ShowTodayTasksIntent: AppIntent {
    static var title: LocalizedStringResource = "Ïò§Îäò Ìï† Ïùº"
    static var description = IntentDescription("Ïò§Îäò Ìï¥Ïïº Ìï† ÏûëÏóÖÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§")
    
    func perform() async throws -> some IntentResult & ShowsSnippetView & OpensIntent {
        let tasks = try await TaskManager.shared.getTodayTasks()
        
        if tasks.isEmpty {
            return .result(
                view: EmptyTodayView(),
                opensIntent: AddTaskIntent()
            )
        } else {
            return .result(
                view: TodayTasksView(tasks: tasks),
                opensIntent: OpenTaskListIntent()
            )
        }
    }
}

// MARK: - ÏûëÏóÖ ÏôÑÎ£å

struct CompleteTaskIntent: AppIntent {
    static var title: LocalizedStringResource = "ÏûëÏóÖ ÏôÑÎ£å"
    static var description = IntentDescription("ÏûëÏóÖÏùÑ ÏôÑÎ£å Ï≤òÎ¶¨Ìï©ÎãàÎã§")
    
    @Parameter(title: "ÏûëÏóÖ", requestValueDialog: "Ïñ¥Îñ§ ÏûëÏóÖÏùÑ ÏôÑÎ£åÌñàÎÇòÏöî?")
    var task: TaskEntity
    
    static var parameterSummary: some ParameterSummary {
        Summary("ÏûëÏóÖ \(\.$task) ÏôÑÎ£å")
    }
    
    func perform() async throws -> some IntentResult & ShowsSnippetView {
        try await TaskManager.shared.completeTask(task.id)
        
        // ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏
        WidgetCenter.shared.reloadAllTimelines()
        
        // Ï∂ïÌïò Ïï†ÎãàÎ©îÏù¥ÏÖòÍ≥º Ìï®Íªò Í≤∞Í≥º ÌëúÏãú
        return .result(view: TaskCompletedView(task: task))
    }
}

// MARK: - Ìè¨Î™®ÎèÑÎ°ú ÏãúÏûë

struct StartPomodoroIntent: AppIntent {
    static var title: LocalizedStringResource = "Ìè¨Î™®ÎèÑÎ°ú ÏãúÏûë"
    static var description = IntentDescription("ÏÑ†ÌÉùÌïú ÏûëÏóÖÏúºÎ°ú Ìè¨Î™®ÎèÑÎ°ú ÌÉÄÏù¥Î®∏Î•º ÏãúÏûëÌï©ÎãàÎã§")
    
    @Parameter(title: "ÏûëÏóÖ")
    var task: TaskEntity?
    
    @Parameter(title: "ÏãúÍ∞Ñ", default: 25)
    var duration: Int
    
    func perform() async throws -> some IntentResult & OpensIntent {
        let pomodoroManager = PomodoroManager.shared
        
        pomodoroManager.startSession(
            task: task,
            duration: TimeInterval(duration * 60)
        )
        
        // Live Activity ÏãúÏûë
        if #available(iOS 16.1, *) {
            try await startPomodoroActivity()
        }
        
        return .result(opensIntent: OpenPomodoroIntent())
    }
    
    @available(iOS 16.1, *)
    private func startPomodoroActivity() async throws {
        let attributes = PomodoroAttributes(
            taskName: task?.title ?? "ÏßëÏ§ë ÏãúÍ∞Ñ",
            duration: duration
        )
        
        let state = PomodoroAttributes.ContentState(
            timeRemaining: duration * 60,
            isRunning: true
        )
        
        let activity = try Activity.request(
            attributes: attributes,
            content: .init(state: state, staleDate: nil),
            pushType: .token
        )
        
        // ÌÜ†ÌÅ∞ Ï†ÄÏû•
        Task {
            for await pushToken in activity.pushTokenUpdates {
                let tokenString = pushToken.map { String(format: "%02x", $0) }.joined()
                await PomodoroManager.shared.savePushToken(tokenString)
            }
        }
    }
}

// MARK: - Entity Types

struct TaskEntity: AppEntity {
    let id: UUID
    let title: String
    let dueDate: Date?
    let priority: String
    let isCompleted: Bool
    
    static var typeDisplayRepresentation: TypeDisplayRepresentation = "ÏûëÏóÖ"
    
    static var defaultQuery = TaskQuery()
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(
            title: "\(title)",
            subtitle: dueDate != nil ? "\(dueDate!, format: .dateTime)" : nil,
            image: priority == "urgent" ? .init(systemName: "exclamationmark.3") : .init(systemName: "checklist")
        )
    }
}

struct TaskQuery: EntityQuery {
    func entities(for identifiers: [UUID]) async throws -> [TaskEntity] {
        try await TaskManager.shared.getTasks(with: identifiers)
            .map { TaskEntity(from: $0) }
    }
    
    func suggestedEntities() async throws -> IntentItemCollection<TaskEntity> {
        let tasks = try await TaskManager.shared.getIncompleteTasks(limit: 10)
        return IntentItemCollection(items: tasks.map { TaskEntity(from: $0) })
    }
    
    func entities(matching query: String) async throws -> IntentItemCollection<TaskEntity> {
        let tasks = try await TaskManager.shared.searchTasks(query: query)
        return IntentItemCollection(items: tasks.map { TaskEntity(from: $0) })
    }
}

// MARK: - Options Provider

struct DueDateOptionsProvider: DynamicOptionsProvider {
    func results() async throws -> IntentItemCollection<DueDateOption> {
        return IntentItemCollection(items: [
            DueDateOption(title: "Ïò§Îäò", date: Date()),
            DueDateOption(title: "ÎÇ¥Ïùº", date: Date().addingTimeInterval(86400)),
            DueDateOption(title: "Ïù¥Î≤à Ï£ºÎßê", date: nextWeekend()),
            DueDateOption(title: "Îã§Ïùå Ï£º", date: nextWeek())
        ])
    }
}

struct DueDateOption: AppEntity {
    let id = UUID()
    let title: String
    let date: Date
    
    static var typeDisplayRepresentation: TypeDisplayRepresentation = "ÎßàÍ∞êÏùº"
    static var defaultQuery = DueDateQuery()
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(title: "\(title)")
    }
}

// MARK: - Snippet Views

struct TaskAddedView: View {
    let task: Task
    
    var body: some View {
        HStack {
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
                .font(.title)
            
            VStack(alignment: .leading) {
                Text("ÏûëÏóÖ Ï∂îÍ∞ÄÎê®")
                    .font(.headline)
                Text(task.title)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            Spacer()
        }
        .padding()
    }
}

struct TodayTasksView: View {
    let tasks: [Task]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: "calendar.day.timeline.left")
                    .foregroundColor(.blue)
                Text("Ïò§Îäò Ìï† Ïùº \(tasks.count)Í∞ú")
                    .font(.headline)
            }
            
            ForEach(tasks.prefix(3)) { task in
                HStack {
                    Image(systemName: task.isCompleted ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(task.isCompleted ? .green : .gray)
                    
                    VStack(alignment: .leading) {
                        Text(task.title)
                            .font(.subheadline)
                            .strikethrough(task.isCompleted)
                        
                        if let dueDate = task.dueDate {
                            Text(dueDate, style: .time)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    
                    Spacer()
                    
                    if task.priority == .urgent {
                        Image(systemName: "exclamationmark.3")
                            .foregroundColor(.red)
                            .font(.caption)
                    }
                }
            }
            
            if tasks.count > 3 {
                Text("Ïô∏ \(tasks.count - 3)Í∞ú...")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
    }
}
```

### 2Îã®Í≥Ñ: App Shortcuts Ï†ïÏùò

**Shortcuts/AppShortcuts.swift**:

```swift
import AppIntents
import Foundation

struct TaskMasterShortcuts: AppShortcutsProvider {
    static var appShortcuts: [AppShortcut] {
        AppShortcut(
            intent: AddTaskIntent(),
            phrases: [
                "TaskMasterÏóêÏÑú ÏûëÏóÖ Ï∂îÍ∞Ä",
                "TaskMasterÏóêÏÑú \(\.$title) Ï∂îÍ∞Ä",
                "TaskMasterÏóêÏÑú \(\.$title) ÏûëÏóÖ \(\.$dueDate)ÍπåÏßÄ",
                "TaskMasterÏóêÏÑú \(\.$priority) Ïö∞ÏÑ†ÏàúÏúÑÎ°ú \(\.$title) Ï∂îÍ∞Ä"
            ],
            shortTitle: "ÏûëÏóÖ Ï∂îÍ∞Ä",
            systemImageName: "plus.circle"
        )
        
        AppShortcut(
            intent: ShowTodayTasksIntent(),
            phrases: [
                "TaskMasterÏóêÏÑú Ïò§Îäò Ìï† Ïùº",
                "Ïò§Îäò Î≠êÌï¥Ïïº ÎêòÏßÄ",
                "TaskMaster Ïò§Îäò ÏùºÏ†ï"
            ],
            shortTitle: "Ïò§Îäò Ìï† Ïùº",
            systemImageName: "calendar.day.timeline.left"
        )
        
        AppShortcut(
            intent: CompleteTaskIntent(),
            phrases: [
                "TaskMasterÏóêÏÑú \(\.$task) ÏôÑÎ£å",
                "TaskMasterÏóêÏÑú ÏûëÏóÖ ÏôÑÎ£å",
                "\(\.$task) ÎÅùÎÉàÏñ¥"
            ],
            shortTitle: "ÏûëÏóÖ ÏôÑÎ£å",
            systemImageName: "checkmark.circle"
        )
        
        AppShortcut(
            intent: StartPomodoroIntent(),
            phrases: [
                "TaskMasterÏóêÏÑú Ìè¨Î™®ÎèÑÎ°ú ÏãúÏûë",
                "TaskMasterÏóêÏÑú \(\.$task)Î°ú ÏßëÏ§ë ÏãúÍ∞Ñ",
                "\(\.$duration)Î∂Ñ ÌÉÄÏù¥Î®∏ ÏãúÏûë"
            ],
            shortTitle: "Ìè¨Î™®ÎèÑÎ°ú",
            systemImageName: "timer"
        )
    }
}
```

### 3Îã®Í≥Ñ: Ìôà ÌôîÎ©¥ ÏúÑÏ†Ø

**Widgets/TaskWidget.swift**:

```swift
import WidgetKit
import SwiftUI
import AppIntents

struct TaskWidgetProvider: AppIntentTimelineProvider {
    func placeholder(in context: Context) -> TaskEntry {
        TaskEntry(date: Date(), tasks: Task.previewTasks, configuration: ConfigurationAppIntent())
    }
    
    func snapshot(for configuration: ConfigurationAppIntent, in context: Context) async -> TaskEntry {
        let tasks = await fetchTasks(for: configuration)
        return TaskEntry(date: Date(), tasks: tasks, configuration: configuration)
    }
    
    func timeline(for configuration: ConfigurationAppIntent, in context: Context) async -> Timeline<TaskEntry> {
        var entries: [TaskEntry] = []
        let tasks = await fetchTasks(for: configuration)
        
        // 15Î∂ÑÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏
        for hourOffset in 0..<4 {
            let entryDate = Calendar.current.date(
                byAdding: .minute,
                value: hourOffset * 15,
                to: Date()
            )!
            
            entries.append(TaskEntry(
                date: entryDate,
                tasks: tasks,
                configuration: configuration
            ))
        }
        
        return Timeline(entries: entries, policy: .atEnd)
    }
    
    private func fetchTasks(for configuration: ConfigurationAppIntent) async -> [Task] {
        do {
            switch configuration.filter {
            case .today:
                return try await TaskManager.shared.getTodayTasks()
            case .upcoming:
                return try await TaskManager.shared.getUpcomingTasks()
            case .overdue:
                return try await TaskManager.shared.getOverdueTasks()
            case .highPriority:
                return try await TaskManager.shared.getHighPriorityTasks()
            }
        } catch {
            return []
        }
    }
}

struct TaskEntry: TimelineEntry {
    let date: Date
    let tasks: [Task]
    let configuration: ConfigurationAppIntent
}

struct TaskWidgetView: View {
    @Environment(\.widgetFamily) var widgetFamily
    var entry: TaskWidgetProvider.Entry
    
    var body: some View {
        switch widgetFamily {
        case .systemSmall:
            SmallTaskWidget(entry: entry)
        case .systemMedium:
            MediumTaskWidget(entry: entry)
        case .systemLarge:
            LargeTaskWidget(entry: entry)
        case .accessoryCircular:
            CircularTaskWidget(entry: entry)
        case .accessoryRectangular:
            RectangularTaskWidget(entry: entry)
        case .accessoryInline:
            InlineTaskWidget(entry: entry)
        default:
            EmptyView()
        }
    }
}

// MARK: - Small Widget

struct SmallTaskWidget: View {
    let entry: TaskWidgetProvider.Entry
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Image(systemName: entry.configuration.filter.icon)
                    .foregroundColor(.blue)
                Text(entry.configuration.filter.title)
                    .font(.caption)
                    .fontWeight(.semibold)
            }
            
            if entry.tasks.isEmpty {
                Spacer()
                Text("ÏûëÏóÖ ÏóÜÏùå")
                    .font(.caption)
                    .foregroundColor(.secondary)
                Spacer()
            } else {
                ForEach(entry.tasks.prefix(3)) { task in
                    TaskRowCompact(task: task)
                }
            }
            
            Spacer()
            
            HStack {
                Text("\(entry.tasks.count)Í∞ú")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                Text(entry.date, style: .time)
                    .font(.caption2)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .widgetURL(URL(string: "taskmaster://tasks/\(entry.configuration.filter.rawValue)"))
    }
}

struct TaskRowCompact: View {
    let task: Task
    
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: task.isCompleted ? "checkmark.circle.fill" : "circle")
                .font(.caption2)
                .foregroundColor(task.isCompleted ? .green : priorityColor)
            
            Text(task.title)
                .font(.caption)
                .lineLimit(1)
                .strikethrough(task.isCompleted)
            
            Spacer()
            
            if task.isOverdue {
                Image(systemName: "exclamationmark.triangle.fill")
                    .font(.caption2)
                    .foregroundColor(.red)
            }
        }
    }
    
    var priorityColor: Color {
        switch task.priority {
        case .urgent: return .red
        case .high: return .orange
        case .medium: return .blue
        case .low: return .gray
        }
    }
}

// MARK: - Medium Widget

struct MediumTaskWidget: View {
    let entry: TaskWidgetProvider.Entry
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Ìó§Îçî
            HStack {
                VStack(alignment: .leading) {
                    Text(entry.configuration.filter.title)
                        .font(.headline)
                    Text("\(entry.tasks.count)Í∞ú ÏûëÏóÖ")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                Spacer()
                
                // ÏßÑÌñâÎ•†
                if !entry.tasks.isEmpty {
                    ProgressCircle(
                        progress: Double(entry.tasks.filter { $0.isCompleted }.count) / Double(entry.tasks.count)
                    )
                    .frame(width: 40, height: 40)
                }
            }
            
            // ÏûëÏóÖ Î™©Î°ù
            if entry.tasks.isEmpty {
                HStack {
                    Spacer()
                    Text("ÏûëÏóÖ ÏóÜÏùå")
                        .foregroundColor(.secondary)
                    Spacer()
                }
            } else {
                VStack(spacing: 6) {
                    ForEach(entry.tasks.prefix(3)) { task in
                        MediumTaskRow(task: task)
                    }
                }
            }
            
            Spacer()
        }
        .padding()
        .widgetURL(URL(string: "taskmaster://tasks/\(entry.configuration.filter.rawValue)"))
    }
}

struct MediumTaskRow: View {
    let task: Task
    
    var body: some View {
        HStack {
            Button(intent: CompleteTaskIntent(task: TaskEntity(from: task))) {
                Image(systemName: task.isCompleted ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(task.isCompleted ? .green : .gray)
            }
            .buttonStyle(.plain)
            
            VStack(alignment: .leading, spacing: 2) {
                Text(task.title)
                    .font(.subheadline)
                    .lineLimit(1)
                    .strikethrough(task.isCompleted)
                
                if let dueDate = task.dueDate {
                    Text(dueDate, style: .time)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
            }
            
            Spacer()
            
            if task.priority == .urgent {
                Image(systemName: "exclamationmark.3")
                    .foregroundColor(.red)
                    .font(.caption)
            }
        }
    }
}

// MARK: - Large Widget

struct LargeTaskWidget: View {
    let entry: TaskWidgetProvider.Entry
    @State private var selectedTab = 0
    
    var body: some View {
        VStack(spacing: 0) {
            // Ìó§Îçî with tabs
            HStack {
                Text("TaskMaster")
                    .font(.title2)
                    .fontWeight(.bold)
                
                Spacer()
                
                Button(intent: AddTaskIntent()) {
                    Image(systemName: "plus.circle.fill")
                        .font(.title2)
                        .foregroundColor(.blue)
                }
                .buttonStyle(.plain)
            }
            .padding()
            
            // ÌÜµÍ≥Ñ
            HStack(spacing: 16) {
                StatCard(
                    title: "Ïò§Îäò",
                    value: "\(entry.tasks.filter { $0.isDueToday }.count)",
                    color: .blue
                )
                
                StatCard(
                    title: "Í∏∞Ìïú ÏßÄÎÇ®",
                    value: "\(entry.tasks.filter { $0.isOverdue }.count)",
                    color: .red
                )
                
                StatCard(
                    title: "ÏôÑÎ£å",
                    value: "\(entry.tasks.filter { $0.isCompleted }.count)",
                    color: .green
                )
                
                StatCard(
                    title: "ÏßÑÌñâÎ•†",
                    value: "\(Int((Double(entry.tasks.filter { $0.isCompleted }.count) / Double(max(entry.tasks.count, 1))) * 100))%",
                    color: .orange
                )
            }
            .padding(.horizontal)
            
            // ÏûëÏóÖ Î™©Î°ù
            ScrollView {
                VStack(spacing: 8) {
                    ForEach(entry.tasks.prefix(6)) { task in
                        LargeTaskRow(task: task)
                            .padding(.horizontal)
                    }
                }
                .padding(.vertical, 8)
            }
            
            Spacer()
        }
        .widgetURL(URL(string: "taskmaster://tasks"))
    }
}

struct StatCard: View {
    let title: String
    let value: String
    let color: Color
    
    var body: some View {
        VStack(spacing: 4) {
            Text(value)
                .font(.headline)
                .foregroundColor(color)
            Text(title)
                .font(.caption2)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 8)
        .background(color.opacity(0.1))
        .cornerRadius(8)
    }
}

// MARK: - Lock Screen Widgets

struct CircularTaskWidget: View {
    let entry: TaskWidgetProvider.Entry
    
    var body: some View {
        ZStack {
            AccessoryWidgetBackground()
            
            VStack {
                Image(systemName: "checklist")
                    .font(.title2)
                
                Text("\(entry.tasks.filter { !$0.isCompleted }.count)")
                    .font(.headline)
            }
        }
    }
}

struct RectangularTaskWidget: View {
    let entry: TaskWidgetProvider.Entry
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Image(systemName: "checklist")
                Text("ÏûëÏóÖ")
                Spacer()
                Text("\(entry.tasks.filter { !$0.isCompleted }.count)")
            }
            .font(.caption)
            
            if let nextTask = entry.tasks.first(where: { !$0.isCompleted }) {
                Text(nextTask.title)
                    .font(.caption2)
                    .lineLimit(2)
            }
        }
    }
}

// MARK: - Widget Configuration

struct ConfigurationAppIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "ÏúÑÏ†Ø ÏÑ§Ï†ï"
    static var description = IntentDescription("ÌëúÏãúÌï† ÏûëÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî")
    
    @Parameter(title: "ÌïÑÌÑ∞", default: .today)
    var filter: TaskFilterOption
}

enum TaskFilterOption: String, AppEnum {
    case today = "today"
    case upcoming = "upcoming"
    case overdue = "overdue"
    case highPriority = "high"
    
    static var typeDisplayRepresentation: TypeDisplayRepresentation = "ÌïÑÌÑ∞"
    
    static var caseDisplayRepresentations: [TaskFilterOption: DisplayRepresentation] = [
        .today: "Ïò§Îäò",
        .upcoming: "ÏòàÏ†ï",
        .overdue: "Í∏∞Ìïú ÏßÄÎÇ®",
        .highPriority: "Ï§ëÏöî"
    ]
    
    var title: String {
        switch self {
        case .today: return "Ïò§Îäò"
        case .upcoming: return "ÏòàÏ†ï"
        case .overdue: return "Í∏∞Ìïú ÏßÄÎÇ®"
        case .highPriority: return "Ï§ëÏöî"
        }
    }
    
    var icon: String {
        switch self {
        case .today: return "calendar.day.timeline.left"
        case .upcoming: return "calendar"
        case .overdue: return "exclamationmark.triangle"
        case .highPriority: return "flag.fill"
        }
    }
}

// MARK: - Widget Bundle

@main
struct TaskWidgetBundle: WidgetBundle {
    var body: some Widget {
        TaskWidget()
        PomodoroWidget()
        TaskStatsWidget()
    }
}

struct TaskWidget: Widget {
    let kind: String = "TaskWidget"
    
    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: kind,
            intent: ConfigurationAppIntent.self,
            provider: TaskWidgetProvider()
        ) { entry in
            TaskWidgetView(entry: entry)
                .containerBackground(.fill.tertiary, for: .widget)
        }
        .configurationDisplayName("ÏûëÏóÖ Î™©Î°ù")
        .description("Ìï† Ïùº Î™©Î°ùÏùÑ ÌïúÎààÏóê ÌôïÏù∏ÌïòÏÑ∏Ïöî")
        .supportedFamilies([
            .systemSmall,
            .systemMedium,
            .systemLarge,
            .accessoryCircular,
            .accessoryRectangular,
            .accessoryInline
        ])
    }
}
```

### 4Îã®Í≥Ñ: Live Activities

**LiveActivities/PomodoroActivity.swift**:

```swift
import ActivityKit
import SwiftUI
import WidgetKit

struct PomodoroAttributes: ActivityAttributes {
    public struct ContentState: Codable, Hashable {
        var timeRemaining: Int
        var isRunning: Bool
        var isBreak: Bool = false
    }
    
    var taskName: String
    var duration: Int
}

struct PomodoroActivityWidget: Widget {
    var body: some WidgetConfiguration {
        ActivityConfiguration(for: PomodoroAttributes.self) { context in
            // Lock Screen View
            PomodoroLockScreenView(context: context)
                .padding()
                .activityBackgroundTint(context.state.isBreak ? Color.green : Color.orange)
                .activitySystemActionForegroundColor(Color.white)
            
        } dynamicIsland: { context in
            DynamicIsland {
                // Expanded View
                DynamicIslandExpandedRegion(.leading) {
                    Image(systemName: context.state.isBreak ? "cup.and.saucer" : "timer")
                        .font(.title2)
                        .foregroundColor(.white)
                }
                
                DynamicIslandExpandedRegion(.center) {
                    VStack {
                        Text(context.attributes.taskName)
                            .font(.headline)
                            .lineLimit(1)
                        
                        Text(timeString(from: context.state.timeRemaining))
                            .font(.system(size: 36, weight: .bold, design: .monospaced))
                            .foregroundColor(context.state.isBreak ? .green : .orange)
                        
                        HStack(spacing: 20) {
                            Button(intent: PausePomodoroIntent()) {
                                Image(systemName: context.state.isRunning ? "pause.fill" : "play.fill")
                                    .font(.title3)
                            }
                            
                            Button(intent: SkipPomodoroIntent()) {
                                Image(systemName: "forward.end.fill")
                                    .font(.title3)
                            }
                            
                            Button(intent: StopPomodoroIntent()) {
                                Image(systemName: "stop.fill")
                                    .font(.title3)
                            }
                        }
                        .padding(.top, 8)
                    }
                }
                
                DynamicIslandExpandedRegion(.trailing) {
                    ProgressCircle(
                        progress: Double(context.attributes.duration * 60 - context.state.timeRemaining) / Double(context.attributes.duration * 60)
                    )
                    .frame(width: 50, height: 50)
                }
                
            } compactLeading: {
                Image(systemName: "timer")
                    .foregroundColor(context.state.isBreak ? .green : .orange)
            } compactTrailing: {
                Text(timeString(from: context.state.timeRemaining))
                    .font(.caption)
                    .fontDesign(.monospaced)
                    .foregroundColor(context.state.isBreak ? .green : .orange)
            } minimal: {
                Image(systemName: "timer")
                    .foregroundColor(context.state.isBreak ? .green : .orange)
            }
            .widgetURL(URL(string: "taskmaster://pomodoro"))
            .keylineTint(context.state.isBreak ? .green : .orange)
        }
    }
    
    private func timeString(from seconds: Int) -> String {
        let minutes = seconds / 60
        let remainingSeconds = seconds % 60
        return String(format: "%02d:%02d", minutes, remainingSeconds)
    }
}

struct PomodoroLockScreenView: View {
    let context: ActivityViewContext<PomodoroAttributes>
    
    var body: some View {
        VStack(spacing: 16) {
            HStack {
                VStack(alignment: .leading) {
                    Text(context.state.isBreak ? "Ìú¥Ïãù ÏãúÍ∞Ñ" : "ÏßëÏ§ë ÏãúÍ∞Ñ")
                        .font(.caption)
                        .foregroundColor(.white.opacity(0.8))
                    
                    Text(context.attributes.taskName)
                        .font(.headline)
                        .foregroundColor(.white)
                }
                
                Spacer()
                
                // ÌÉÄÏù¥Î®∏
                Text(timeString)
                    .font(.system(size: 32, weight: .bold, design: .monospaced))
                    .foregroundColor(.white)
            }
            
            // ÏßÑÌñâÎ•† Î∞î
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.white.opacity(0.2))
                        .frame(height: 8)
                    
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.white)
                        .frame(width: geometry.size.width * progress, height: 8)
                }
            }
            .frame(height: 8)
            
            // Ïª®Ìä∏Î°§ Î≤ÑÌäº
            HStack(spacing: 20) {
                Button(intent: PausePomodoroIntent()) {
                    Image(systemName: context.state.isRunning ? "pause.fill" : "play.fill")
                        .font(.title3)
                        .foregroundColor(.white)
                }
                
                Button(intent: SkipPomodoroIntent()) {
                    Image(systemName: "forward.end.fill")
                        .font(.title3)
                        .foregroundColor(.white)
                }
            }
        }
    }
    
    var timeString: String {
        let minutes = context.state.timeRemaining / 60
        let seconds = context.state.timeRemaining % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
    
    var progress: Double {
        let total = context.attributes.duration * 60
        let elapsed = total - context.state.timeRemaining
        return Double(elapsed) / Double(total)
    }
}

// MARK: - Control Intents

struct PausePomodoroIntent: AppIntent {
    static var title: LocalizedStringResource = "ÏùºÏãúÏ†ïÏßÄ"
    
    func perform() async throws -> some IntentResult {
        PomodoroManager.shared.togglePause()
        return .result()
    }
}

struct SkipPomodoroIntent: AppIntent {
    static var title: LocalizedStringResource = "Í±¥ÎÑàÎõ∞Í∏∞"
    
    func perform() async throws -> some IntentResult {
        PomodoroManager.shared.skip()
        return .result()
    }
}

struct StopPomodoroIntent: AppIntent {
    static var title: LocalizedStringResource = "Ï§ëÏßÄ"
    
    func perform() async throws -> some IntentResult {
        PomodoroManager.shared.stop()
        
        // Live Activity Ï¢ÖÎ£å
        for activity in Activity<PomodoroAttributes>.activities {
            await activity.end(nil, dismissalPolicy: .immediate)
        }
        
        return .result()
    }
}

// MARK: - Progress Circle

struct ProgressCircle: View {
    let progress: Double
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(Color.gray.opacity(0.2), lineWidth: 4)
            
            Circle()
                .trim(from: 0, to: progress)
                .stroke(
                    progress > 0.8 ? Color.green : Color.orange,
                    style: StrokeStyle(lineWidth: 4, lineCap: .round)
                )
                .rotationEffect(.degrees(-90))
                .animation(.linear, value: progress)
            
            Text("\(Int(progress * 100))%")
                .font(.caption2)
                .fontWeight(.bold)
        }
    }
}
```

---

## üéØ Ïó¨Í∏∞ÏÑú Î∞∞Ïö¥ Í≤É

### 1. **App Intents**
- Siri ÌÜµÌï©
- ÌååÎùºÎØ∏ÌÑ∞ Ï≤òÎ¶¨
- ÏùåÏÑ± ÌîºÎìúÎ∞±
- Shortcuts Ïï± Ïó∞Îèô

### 2. **ÏúÑÏ†Ø Í∞úÎ∞ú**
- Timeline Provider
- Îã§ÏñëÌïú ÌÅ¨Í∏∞ ÏßÄÏõê
- Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Î≤ÑÌäº
- ÏÑ§Ï†ï Í∞ÄÎä•Ìïú ÏúÑÏ†Ø

### 3. **Live Activities**
- Dynamic Island
- Ïû†Í∏à ÌôîÎ©¥ ÌëúÏãú
- Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
- Ìë∏Ïãú ÏïåÎ¶º Ïó∞Îèô

### 4. **ÏãúÏä§ÌÖú ÌÜµÌï©**
- URL Scheme
- Deep Linking
- Background Tasks
- Widget ÏóÖÎç∞Ïù¥Ìä∏

---

## üéâ ÏÑ±Í≥µ ÌôïÏù∏

**Shortcuts & ÏúÑÏ†Ø Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏**:
- [ ] SiriÎ°ú ÏûëÏóÖ Ï∂îÍ∞Ä Í∞ÄÎä•
- [ ] Ìôà ÌôîÎ©¥ ÏúÑÏ†Ø ÌëúÏãú
- [ ] Dynamic IslandÏóêÏÑú Ìè¨Î™®ÎèÑÎ°ú ÌëúÏãú
- [ ] Ïû†Í∏à ÌôîÎ©¥ ÏúÑÏ†Ø ÏûëÎèô
- [ ] Shortcuts Ïï±ÏóêÏÑú ÏûêÎèôÌôî Í∞ÄÎä•

---

**ÏôÑÎ≤ΩÌï©ÎãàÎã§! TaskMaster Ïï±Ïù¥ ÏãúÏä§ÌÖú Ï†ÑÏ≤¥ÏôÄ ÌÜµÌï©ÎêòÏóàÏäµÎãàÎã§.**
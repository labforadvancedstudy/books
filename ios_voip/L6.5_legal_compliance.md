# 레벨 6.5: 법적 이슈와 컴플라이언스 - "코드보다 무서운 법"

*2024년 8월. GDPR 위반 통지서 도착.*

법무팀: "유럽 사용자 데이터 삭제 요청을 30일 내 처리 안 했다고 하네요."
나: "통화 기록만 지웠는데..."
법무팀: "서버 로그, 백업, CDN 캐시는요?"
나: (아... 진짜 '모든' 데이터를 지워야 했구나)

## GDPR 완벽 대응

### Right to be Forgotten 구현

```swift
// GDPR Article 17: 삭제권 (잊혀질 권리)
class GDPRCompliance {
    private let dataStores: [DataStore] = [
        .database,
        .fileStorage,
        .cache,
        .logs,
        .backups,
        .analytics,
        .cdn
    ]
    
    // 사용자 데이터 완전 삭제
    func executeRightToBeForgotten(userId: String) async throws {
        // 1. 삭제 요청 기록 (감사 추적)
        await logDeletionRequest(userId: userId, timestamp: Date())
        
        // 2. 활성 데이터 삭제
        try await deleteActiveData(userId: userId)
        
        // 3. 백업 데이터 표시
        try await markBackupsForDeletion(userId: userId)
        
        // 4. 제3자 서비스 삭제 요청
        try await requestThirdPartyDeletion(userId: userId)
        
        // 5. 삭제 확인서 생성
        let certificate = try await generateDeletionCertificate(userId: userId)
        
        // 6. 사용자에게 통지
        try await notifyUserOfDeletion(userId: userId, certificate: certificate)
    }
    
    private func deleteActiveData(userId: String) async throws {
        // 데이터베이스
        try await database.execute("""
            DELETE FROM users WHERE id = ?;
            DELETE FROM call_history WHERE user_id = ?;
            DELETE FROM messages WHERE sender_id = ? OR receiver_id = ?;
            DELETE FROM user_metadata WHERE user_id = ?;
        """, [userId, userId, userId, userId, userId])
        
        // 파일 스토리지
        let userFiles = try await storage.listFiles(prefix: "users/\(userId)/")
        for file in userFiles {
            try await storage.delete(file)
        }
        
        // 캐시
        try await redis.del("user:\(userId):*")
        
        // 로그 (익명화)
        try await anonymizeLogs(userId: userId)
    }
    
    private func anonymizeLogs(userId: String) async throws {
        // 로그는 삭제하지 않고 익명화
        let anonymousId = "GDPR_DELETED_\(UUID().uuidString)"
        
        // Elasticsearch 로그 업데이트
        let updateQuery = """
        {
            "script": {
                "source": "ctx._source.user_id = params.anonymous_id",
                "params": {
                    "anonymous_id": "\(anonymousId)"
                }
            },
            "query": {
                "term": {
                    "user_id": "\(userId)"
                }
            }
        }
        """
        
        try await elasticsearch.updateByQuery(updateQuery)
    }
}

// GDPR 데이터 이동권 (Article 20)
class DataPortability {
    func exportUserData(userId: String) async throws -> PortableDataPackage {
        let userData = PortableDataPackage()
        
        // 1. 개인 정보
        userData.profile = try await database.query(
            "SELECT * FROM users WHERE id = ?",
            [userId]
        )
        
        // 2. 통화 기록
        userData.callHistory = try await database.query("""
            SELECT 
                call_id,
                caller_id,
                callee_id,
                duration,
                quality_score,
                timestamp
            FROM call_history 
            WHERE user_id = ?
            ORDER BY timestamp DESC
        """, [userId])
        
        // 3. 메시지 (암호화된 상태로)
        userData.messages = try await database.query("""
            SELECT 
                message_id,
                sender_id,
                receiver_id,
                encrypted_content,
                timestamp
            FROM messages
            WHERE sender_id = ? OR receiver_id = ?
        """, [userId, userId])
        
        // 4. 기계 판독 가능 형식으로 변환
        let jsonData = try JSONEncoder().encode(userData)
        let csvData = try convertToCSV(userData)
        
        return PortableDataPackage(
            json: jsonData,
            csv: csvData,
            format: .structured,
            timestamp: Date()
        )
    }
}
```

### 동의 관리 시스템

```swift
// GDPR Article 7: 동의
class ConsentManager {
    struct ConsentRecord {
        let userId: String
        let purpose: ConsentPurpose
        let granted: Bool
        let timestamp: Date
        let ipAddress: String
        let version: String
    }
    
    enum ConsentPurpose: String, CaseIterable {
        case voiceRecording = "voice_recording"
        case analytics = "analytics"
        case marketing = "marketing"
        case qualityImprovement = "quality_improvement"
        case thirdPartySharing = "third_party_sharing"
    }
    
    func requestConsent(
        from userId: String,
        for purpose: ConsentPurpose
    ) async throws -> Bool {
        // 1. 명확하고 평이한 언어로 설명
        let explanation = getLocalizedExplanation(for: purpose)
        
        // 2. 자유로운 철회 가능성 명시
        let withdrawalInfo = """
        이 동의는 언제든지 철회할 수 있습니다.
        설정 > 개인정보 > 동의 관리에서 변경 가능합니다.
        """
        
        // 3. UI에 표시
        let consent = await showConsentDialog(
            explanation: explanation,
            withdrawalInfo: withdrawalInfo
        )
        
        // 4. 동의 기록 저장
        if let consent = consent {
            try await recordConsent(
                userId: userId,
                purpose: purpose,
                granted: consent.granted,
                ipAddress: consent.ipAddress
            )
        }
        
        return consent?.granted ?? false
    }
    
    // 동의 증명 (감사 추적)
    func generateConsentProof(userId: String) async throws -> ConsentProof {
        let records = try await database.query("""
            SELECT * FROM consent_records
            WHERE user_id = ?
            ORDER BY timestamp DESC
        """, [userId])
        
        return ConsentProof(
            userId: userId,
            records: records,
            hash: SHA256.hash(data: records.data),
            timestamp: Date()
        )
    }
}
```

## 통화 녹음 법규

### 국가별 녹음 규제

```swift
// 통화 녹음 법적 요구사항
class CallRecordingCompliance {
    enum RecordingLaw {
        case onePartyConsent    // 한 쪽만 동의 (대부분의 미국 주)
        case twoPartyConsent    // 양쪽 모두 동의 (캘리포니아 등)
        case prohibited         // 녹음 금지
        case notificationRequired  // 알림 필수
    }
    
    func getRecordingLaw(for location: Location) -> RecordingLaw {
        switch location.country {
        case "US":
            switch location.state {
            case "CA", "FL", "IL", "MD", "MA", "MT", "NH", "OR", "PA", "WA":
                return .twoPartyConsent
            default:
                return .onePartyConsent
            }
            
        case "KR":
            return .onePartyConsent  // 한국: 대화 당사자 1인 동의
            
        case "DE", "FR":
            return .twoPartyConsent  // 독일, 프랑스: 양자 동의
            
        case "CN":
            return .notificationRequired  // 중국: 고지 필수
            
        default:
            return .twoPartyConsent  // 안전한 기본값
        }
    }
    
    func startRecording(call: Call) async throws {
        // 1. 법적 요구사항 확인
        let callerLaw = getRecordingLaw(for: call.caller.location)
        let calleeLaw = getRecordingLaw(for: call.callee.location)
        
        // 더 엄격한 법 적용
        let applicableLaw = moreStrict(callerLaw, calleeLaw)
        
        switch applicableLaw {
        case .prohibited:
            throw RecordingError.prohibitedByLaw
            
        case .twoPartyConsent:
            // 양쪽 모두 동의 필요
            let callerConsent = try await requestRecordingConsent(from: call.caller)
            let calleeConsent = try await requestRecordingConsent(from: call.callee)
            
            guard callerConsent && calleeConsent else {
                throw RecordingError.consentNotGranted
            }
            
            // 녹음 시작 알림
            try await notifyRecordingStarted(call: call)
            
        case .onePartyConsent:
            // 한 쪽만 동의하면 됨
            let consent = try await requestRecordingConsent(from: call.initiator)
            guard consent else {
                throw RecordingError.consentNotGranted
            }
            
        case .notificationRequired:
            // 알림만 하면 됨
            try await notifyRecordingStarted(call: call)
        }
        
        // 2. 녹음 시작
        try await startActualRecording(call: call)
        
        // 3. 메타데이터 저장
        try await saveRecordingMetadata(
            callId: call.id,
            law: applicableLaw,
            consentRecords: call.consentRecords,
            startTime: Date()
        )
    }
    
    // 녹음 파일 보관 기간
    func getRetentionPeriod(for location: Location) -> TimeInterval {
        switch location.country {
        case "US":
            return 7 * 365 * 24 * 3600  // 7년 (일부 주)
        case "KR":
            return 3 * 365 * 24 * 3600  // 3년
        case "EU":
            return 6 * 30 * 24 * 3600   // 6개월 (GDPR)
        default:
            return 365 * 24 * 3600       // 1년 (기본)
        }
    }
}
```

## 개인정보 보호

### Privacy by Design

```swift
// Privacy by Design 원칙 구현
class PrivacyByDesign {
    // 1. 최소 수집 원칙
    func collectMinimalData(for purpose: DataPurpose) -> [DataField] {
        switch purpose {
        case .voiceCall:
            return [.phoneNumber]  // 이메일, 이름 등은 불필요
            
        case .registration:
            return [.phoneNumber, .countryCode]
            
        case .billing:
            return [.userId, .usageMinutes]  // 통화 내용은 불필요
        }
    }
    
    // 2. 데이터 익명화
    func anonymizeCallData(_ call: CallRecord) -> AnonymizedCallRecord {
        return AnonymizedCallRecord(
            id: UUID().uuidString,
            duration: call.duration,
            quality: call.qualityScore,
            timestamp: call.timestamp.rounded(to: .hour),  // 시간 단위로 반올림
            region: call.location.country,  // 상세 위치 제거
            // 전화번호, 사용자 ID 등 제거
        )
    }
    
    // 3. 차등 프라이버시
    func addDifferentialPrivacy(to value: Double, epsilon: Double = 1.0) -> Double {
        // Laplace 노이즈 추가
        let scale = 1.0 / epsilon
        let u = Double.random(in: -0.5...0.5)
        let noise = -scale * (u > 0 ? log(1 - 2 * u) : -log(1 + 2 * u))
        return value + noise
    }
    
    // 4. 암호화 저장
    func encryptSensitiveData(_ data: Data) throws -> EncryptedData {
        let key = try getOrCreateDataKey()
        
        // AES-256-GCM 암호화
        let sealedBox = try AES.GCM.seal(
            data,
            using: key,
            nonce: AES.GCM.Nonce()
        )
        
        return EncryptedData(
            ciphertext: sealedBox.ciphertext,
            nonce: sealedBox.nonce,
            tag: sealedBox.tag,
            keyId: key.id
        )
    }
}

// Privacy Manifest (iOS 17+)
struct PrivacyManifest: Codable {
    let NSPrivacyTracking = false
    let NSPrivacyTrackingDomains: [String] = []
    
    let NSPrivacyCollectedDataTypes = [
        [
            "NSPrivacyCollectedDataType": "NSPrivacyCollectedDataTypePhoneNumber",
            "NSPrivacyCollectedDataTypeLinked": true,
            "NSPrivacyCollectedDataTypeTracking": false,
            "NSPrivacyCollectedDataTypePurposes": [
                "NSPrivacyCollectedDataTypePurposeAppFunctionality"
            ]
        ],
        [
            "NSPrivacyCollectedDataType": "NSPrivacyCollectedDataTypeAudioData",
            "NSPrivacyCollectedDataTypeLinked": false,
            "NSPrivacyCollectedDataTypeTracking": false,
            "NSPrivacyCollectedDataTypePurposes": [
                "NSPrivacyCollectedDataTypePurposeAppFunctionality"
            ]
        ]
    ]
    
    let NSPrivacyAccessedAPITypes = [
        [
            "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategoryUserDefaults",
            "NSPrivacyAccessedAPITypeReasons": [
                "CA92.1"  // 앱 기능을 위한 정보 저장
            ]
        ],
        [
            "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategoryFileTimestamp",
            "NSPrivacyAccessedAPITypeReasons": [
                "C617.1"  // 파일 타임스탬프 액세스
            ]
        ]
    ]
}
```

## 각국 규제 대응

### 국가별 컴플라이언스 매트릭스

```swift
class RegionalCompliance {
    struct ComplianceRequirements {
        let dataLocalization: Bool
        let encryptionRequired: Bool
        let auditLogRetention: TimeInterval
        let userConsentRequired: Bool
        let governmentAccessProvision: Bool
    }
    
    func getRequirements(for country: String) -> ComplianceRequirements {
        switch country {
        case "CN":  // 중국
            return ComplianceRequirements(
                dataLocalization: true,  // 데이터 중국 내 저장 필수
                encryptionRequired: true,
                auditLogRetention: 6 * 30 * 24 * 3600,  // 6개월
                userConsentRequired: true,
                governmentAccessProvision: true  // 정부 접근 허용 필수
            )
            
        case "RU":  // 러시아
            return ComplianceRequirements(
                dataLocalization: true,  // 데이터 현지화법
                encryptionRequired: true,
                auditLogRetention: 3 * 365 * 24 * 3600,  // 3년
                userConsentRequired: true,
                governmentAccessProvision: true
            )
            
        case "EU":  // 유럽연합
            return ComplianceRequirements(
                dataLocalization: false,  // EU 내 이동은 자유
                encryptionRequired: true,
                auditLogRetention: 365 * 24 * 3600,  // 1년
                userConsentRequired: true,
                governmentAccessProvision: false  // GDPR 보호
            )
            
        case "US":  // 미국
            return ComplianceRequirements(
                dataLocalization: false,
                encryptionRequired: false,  // 권장사항
                auditLogRetention: 7 * 365 * 24 * 3600,  // 7년 (SOX)
                userConsentRequired: false,  // 주별로 다름
                governmentAccessProvision: true  // FISA, Patriot Act
            )
            
        case "KR":  // 한국
            return ComplianceRequirements(
                dataLocalization: false,
                encryptionRequired: true,  // 정보통신망법
                auditLogRetention: 3 * 365 * 24 * 3600,  // 3년
                userConsentRequired: true,
                governmentAccessProvision: false
            )
            
        default:
            // 안전한 기본값
            return ComplianceRequirements(
                dataLocalization: false,
                encryptionRequired: true,
                auditLogRetention: 365 * 24 * 3600,
                userConsentRequired: true,
                governmentAccessProvision: false
            )
        }
    }
}

// 실제 구현: 중국 데이터 현지화
class ChinaDataLocalization {
    private let cnDatabase: Database  // 중국 내 DB
    private let globalDatabase: Database  // 글로벌 DB
    
    func storeUserData(_ user: User) async throws {
        if user.location.country == "CN" {
            // 중국 사용자 데이터는 중국 서버에만
            try await cnDatabase.insert(user)
            
            // 글로벌 DB에는 참조만
            let reference = UserReference(
                id: user.id,
                region: "CN",
                dataLocation: "cn-beijing-1"
            )
            try await globalDatabase.insert(reference)
        } else {
            // 다른 국가는 글로벌 DB
            try await globalDatabase.insert(user)
        }
    }
}
```

## 실제 사고 사례와 교훈

### 사례 1: WhatsApp의 EU 과징금

```swift
// WhatsApp 사례: 2억 2500만 유로 과징금 (2021)
class WhatsAppCase {
    /*
    위반 사항:
    1. 투명성 부족 (GDPR Article 12, 13, 14)
    2. 데이터 공유 정보 불충분
    3. 비사용자 데이터 처리 미고지
    
    교훈:
    */
    
    func implementTransparency() {
        // 1. 명확한 개인정보 처리 방침
        let privacyPolicy = """
        수집 데이터:
        - 전화번호 (필수): 계정 생성 및 인증
        - 통화 기록 (선택): 서비스 개선
        - 위치 정보 (선택): 가까운 연결 추천
        
        데이터 공유:
        - 제3자 공유 없음
        - 법적 요구시에만 제공
        
        보관 기간:
        - 활성 계정: 무기한
        - 비활성 계정: 180일 후 삭제
        """
        
        // 2. 팝업으로 주요 변경사항 알림
        // 3. 거부 옵션 명확히 제공
    }
}
```

### 사례 2: Zoom의 E2EE 허위 광고

```swift
// Zoom 사례: FTC 합의금 8500만 달러 (2020)
class ZoomCase {
    /*
    문제:
    - "End-to-End Encryption" 광고했지만 실제로는 TLS만 사용
    - 서버에서 복호화 가능했음
    
    해결책:
    */
    
    func implementTrueE2EE() {
        // 1. 실제 E2EE 구현
        class TrueE2EE {
            func encryptForRecipient(
                _ data: Data,
                recipientPublicKey: P256.KeyAgreement.PublicKey
            ) throws -> Data {
                // Signal Protocol 사용
                let sessionKey = try performKeyExchange(with: recipientPublicKey)
                return try encrypt(data, with: sessionKey)
            }
        }
        
        // 2. 명확한 표시
        func showEncryptionStatus() -> String {
            if isE2EEEnabled {
                return "🔒 종단간 암호화 (서버도 볼 수 없음)"
            } else {
                return "🔓 전송 암호화 (서버 복호화 가능)"
            }
        }
    }
}
```

## 컴플라이언스 체크리스트

```swift
struct ComplianceChecklist {
    let items = [
        // GDPR
        ChecklistItem(
            category: "GDPR",
            requirement: "개인정보 처리방침 게시",
            implementation: "앱 내 + 웹사이트",
            deadline: "서비스 시작 전"
        ),
        ChecklistItem(
            category: "GDPR",
            requirement: "DPO(Data Protection Officer) 지정",
            implementation: "250명 이상 기업 필수",
            deadline: "즉시"
        ),
        ChecklistItem(
            category: "GDPR",
            requirement: "데이터 침해 통지",
            implementation: "72시간 내 당국 신고",
            deadline: "침해 인지 후 72시간"
        ),
        
        // CCPA (California)
        ChecklistItem(
            category: "CCPA",
            requirement: "Do Not Sell 옵션",
            implementation: "설정 메뉴에 추가",
            deadline: "2020.1.1"
        ),
        
        // 한국
        ChecklistItem(
            category: "한국",
            requirement: "개인정보 암호화",
            implementation: "주민번호, 비밀번호 등",
            deadline: "즉시"
        ),
        ChecklistItem(
            category: "한국",
            requirement: "접속 기록 보관",
            implementation: "6개월 이상",
            deadline: "즉시"
        )
    ]
    
    func validateCompliance() -> [ComplianceIssue] {
        var issues: [ComplianceIssue] = []
        
        for item in items {
            if !item.isCompleted {
                issues.append(ComplianceIssue(
                    severity: .critical,
                    description: item.requirement,
                    recommendation: item.implementation
                ))
            }
        }
        
        return issues
    }
}
```

## 다음 레벨 예고

레벨 7.5에서는 프로덕션 디버깅:
- 실시간 문제 진단
- 크래시 분석
- 성능 모니터링
- 사용자 피드백 처리

"배포는 시작일 뿐이다"
# 레벨 7.5: 프로덕션 디버깅 - "새벽 3시의 전화"

*2024년 9월. 새벽 3시, 긴급 호출.*

운영팀: "통화 성공률이 30%로 떨어졌습니다!"
나: (잠에서 깨며) "로그 확인했어요?"
운영팀: "에러는 없는데 그냥 연결이 안 돼요."
나: (이런 게 제일 무섭다...)

## 실시간 문제 진단

### 분산 추적 (Distributed Tracing)

```swift
// OpenTelemetry 통합
import OpenTelemetryApi
import OpenTelemetrySdk

class CallTracer {
    private let tracer = OpenTelemetry.instance.tracerProvider.get(
        instrumentationName: "voip-client",
        instrumentationVersion: "1.0.0"
    )
    
    // 통화 전체 흐름 추적
    func traceCall(callId: String) -> Span {
        let span = tracer.spanBuilder(spanName: "call.initiate")
            .setSpanKind(spanKind: .client)
            .setAttribute(key: "call.id", value: callId)
            .setAttribute(key: "platform", value: "iOS")
            .setAttribute(key: "app.version", value: Bundle.main.appVersion)
            .startSpan()
        
        // Context Propagation
        let propagator = W3CTraceContextPropagator()
        var carrier = [String: String]()
        propagator.inject(
            spanContext: span.context,
            carrier: &carrier,
            setter: DictionarySetter()
        )
        
        return span
    }
    
    // 각 단계별 추적
    func traceSignaling(parentSpan: Span) async throws {
        let span = tracer.spanBuilder(spanName: "signaling.connect")
            .setParent(parentSpan)
            .startSpan()
        
        defer { span.end() }
        
        do {
            span.addEvent(name: "websocket.connecting")
            let startTime = Date()
            
            try await connectWebSocket()
            
            let connectionTime = Date().timeIntervalSince(startTime)
            span.setAttribute(key: "connection.duration", value: connectionTime)
            
            if connectionTime > 3.0 {
                span.setStatus(status: .error(description: "Slow connection"))
                span.addEvent(
                    name: "performance.issue",
                    attributes: ["duration": AttributeValue.double(connectionTime)]
                )
            }
            
        } catch {
            span.recordException(error)
            span.setStatus(status: .error(description: error.localizedDescription))
            throw error
        }
    }
}

// 서버측 연동
class ServerTracing {
    func extractTraceContext(from headers: [String: String]) -> SpanContext? {
        let propagator = W3CTraceContextPropagator()
        return propagator.extract(
            carrier: headers,
            getter: DictionaryGetter()
        )
    }
    
    func correlateCallFlow(callId: String) async -> CallFlowAnalysis {
        // Jaeger에서 전체 추적 정보 조회
        let traces = try await jaeger.query(
            service: "voip",
            tags: ["call.id": callId]
        )
        
        // 병목 지점 분석
        let bottlenecks = traces.spans
            .filter { $0.duration > 1000 } // 1초 이상
            .sorted { $0.duration > $1.duration }
        
        // 에러 발생 지점
        let errors = traces.spans
            .filter { $0.status == .error }
        
        return CallFlowAnalysis(
            totalDuration: traces.duration,
            bottlenecks: bottlenecks,
            errors: errors,
            spanCount: traces.spans.count
        )
    }
}
```

### 실시간 메트릭 모니터링

```swift
// 커스텀 메트릭 수집
class MetricsCollector {
    private let statsd = StatsD(host: "metrics.example.com", port: 8125)
    
    // 통화 품질 메트릭
    func recordCallQuality(_ call: Call) {
        // MOS Score
        statsd.gauge("call.mos_score", value: call.mosScore, tags: [
            "region": call.region,
            "network": call.networkType.rawValue,
            "codec": call.codec
        ])
        
        // 패킷 손실
        statsd.histogram("call.packet_loss", value: call.packetLoss, tags: [
            "severity": call.packetLoss > 5 ? "high" : "normal"
        ])
        
        // 지터
        statsd.histogram("call.jitter", value: call.jitter)
        
        // 레이턴시
        statsd.timing("call.latency", value: call.latency)
        
        // 비즈니스 메트릭
        if call.duration > 0 {
            statsd.increment("call.completed")
        } else {
            statsd.increment("call.failed", tags: [
                "reason": call.failureReason ?? "unknown"
            ])
        }
    }
    
    // 실시간 알림 트리거
    func checkThresholds(_ metrics: CallMetrics) {
        if metrics.failureRate > 0.1 {  // 10% 실패율
            sendAlert(
                severity: .critical,
                message: "High call failure rate: \(metrics.failureRate * 100)%",
                runbook: "https://wiki.example.com/runbooks/high-failure-rate"
            )
        }
        
        if metrics.avgMOS < 3.0 {  // 품질 저하
            sendAlert(
                severity: .warning,
                message: "Low call quality: MOS \(metrics.avgMOS)",
                runbook: "https://wiki.example.com/runbooks/low-mos"
            )
        }
    }
}
```

## 크래시 분석

### 심볼리케이션과 스택 트레이스

```swift
// Crashlytics 대체 구현
class CrashReporter {
    private var breadcrumbs: [Breadcrumb] = []
    private let maxBreadcrumbs = 100
    
    // Breadcrumb 기록
    func leaveBreadcrumb(
        message: String,
        category: String,
        level: BreadcrumbLevel = .info,
        data: [String: Any]? = nil
    ) {
        let breadcrumb = Breadcrumb(
            timestamp: Date(),
            message: message,
            category: category,
            level: level,
            data: data
        )
        
        breadcrumbs.append(breadcrumb)
        if breadcrumbs.count > maxBreadcrumbs {
            breadcrumbs.removeFirst()
        }
    }
    
    // 크래시 핸들러
    func setupCrashHandler() {
        NSSetUncaughtExceptionHandler { exception in
            self.handleException(exception)
        }
        
        // Signal 핸들러
        signal(SIGABRT) { _ in
            self.handleSignal("SIGABRT")
        }
        signal(SIGSEGV) { _ in
            self.handleSignal("SIGSEGV")
        }
        signal(SIGBUS) { _ in
            self.handleSignal("SIGBUS")
        }
    }
    
    private func handleException(_ exception: NSException) {
        let crash = CrashReport(
            id: UUID().uuidString,
            timestamp: Date(),
            appVersion: Bundle.main.appVersion,
            osVersion: UIDevice.current.systemVersion,
            deviceModel: UIDevice.current.modelName,
            exception: ExceptionInfo(
                name: exception.name.rawValue,
                reason: exception.reason,
                stackTrace: exception.callStackSymbols
            ),
            breadcrumbs: breadcrumbs,
            customData: gatherCustomData()
        )
        
        // 로컬 저장 (다음 실행시 전송)
        saveCrashReport(crash)
        
        // 심볼리케이션을 위한 dSYM 정보
        attachDSYMInfo(to: crash)
    }
    
    // 프로덕션 크래시 분석
    func analyzeCrash(_ report: CrashReport) -> CrashAnalysis {
        // 1. 스택 트레이스 심볼리케이션
        let symbolicated = symbolicate(report.stackTrace)
        
        // 2. 크래시 패턴 인식
        let pattern = identifyPattern(symbolicated)
        
        // 3. 영향 범위 계산
        let impact = calculateImpact(report)
        
        // 4. 근본 원인 추정
        let rootCause = findRootCause(symbolicated, breadcrumbs: report.breadcrumbs)
        
        return CrashAnalysis(
            crashId: report.id,
            pattern: pattern,
            impact: impact,
            rootCause: rootCause,
            suggestedFix: generateFixSuggestion(rootCause)
        )
    }
}

// 메모리 문제 디버깅
class MemoryDebugger {
    func detectMemoryLeaks() {
        // Instruments 자동화
        let leaksDetector = LeaksDetector()
        
        leaksDetector.onLeakDetected = { leak in
            print("""
            ⚠️ 메모리 누수 감지:
            객체: \(leak.className)
            크기: \(leak.size) bytes
            스택:
            \(leak.allocationBacktrace.joined(separator: "\n"))
            """)
            
            // 프로덕션에서는 로그만
            Analytics.track("memory_leak", properties: [
                "class": leak.className,
                "size": leak.size
            ])
        }
        
        // 주기적 체크
        Timer.scheduledTimer(withTimeInterval: 60, repeats: true) { _ in
            let memoryUsage = self.getCurrentMemoryUsage()
            if memoryUsage > 200_000_000 {  // 200MB
                self.generateMemoryReport()
            }
        }
    }
}
```

## 성능 모니터링

### 실시간 성능 지표

```swift
// 프레임 드랍 감지
class PerformanceMonitor {
    private var displayLink: CADisplayLink?
    private var lastTimestamp: CFTimeInterval = 0
    private var frameDrops = 0
    
    func startMonitoring() {
        displayLink = CADisplayLink(target: self, selector: #selector(tick))
        displayLink?.add(to: .main, forMode: .common)
    }
    
    @objc private func tick(_ displayLink: CADisplayLink) {
        if lastTimestamp == 0 {
            lastTimestamp = displayLink.timestamp
            return
        }
        
        let frameDuration = displayLink.timestamp - lastTimestamp
        lastTimestamp = displayLink.timestamp
        
        // 60 FPS = 16.67ms per frame
        if frameDuration > 0.020 {  // 20ms = 50 FPS
            frameDrops += 1
            
            if frameDrops > 10 {
                reportPerformanceIssue(
                    type: .frameDrops,
                    severity: frameDrops > 30 ? .critical : .warning,
                    context: captureContext()
                )
            }
        }
    }
    
    // 네트워크 성능
    func monitorNetworkPerformance() {
        URLSession.shared.delegateQueue = OperationQueue()
        
        // Request 인터셉터
        URLProtocol.registerClass(NetworkMonitorProtocol.self)
    }
}

class NetworkMonitorProtocol: URLProtocol {
    override class func canInit(with request: URLRequest) -> Bool {
        return true
    }
    
    override func startLoading() {
        let startTime = CFAbsoluteTimeGetCurrent()
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            let duration = CFAbsoluteTimeGetCurrent() - startTime
            
            // 메트릭 기록
            MetricsCollector.shared.recordNetworkRequest(
                url: self.request.url?.absoluteString ?? "",
                duration: duration,
                statusCode: (response as? HTTPURLResponse)?.statusCode ?? 0,
                error: error,
                bytesReceived: data?.count ?? 0
            )
            
            // 느린 요청 감지
            if duration > 3.0 {
                Analytics.track("slow_request", properties: [
                    "url": self.request.url?.absoluteString ?? "",
                    "duration": duration
                ])
            }
        }
        task.resume()
    }
}
```

## 사용자 피드백 처리

### 실시간 피드백 수집

```swift
// 통화 중 피드백
class InCallFeedback {
    func showQualityIssueButton() {
        // 통화 중 품질 문제 버튼
        let button = UIButton()
        button.setImage(UIImage(systemName: "exclamationmark.triangle"), for: .normal)
        button.addTarget(self, action: #selector(reportIssue), for: .touchUpInside)
    }
    
    @objc func reportIssue() {
        // 즉시 상태 캡처
        let snapshot = CaptureCallState()
        
        let feedback = CallFeedback(
            callId: currentCall.id,
            timestamp: Date(),
            issue: nil,  // 사용자가 선택
            snapshot: snapshot
        )
        
        // 문제 유형 선택
        showIssueSelector { issue in
            feedback.issue = issue
            
            // 즉시 전송
            self.sendFeedback(feedback)
            
            // 로컬 로그 저장
            self.saveLocalDiagnostics(feedback)
        }
    }
    
    func captureCallState() -> CallStateSnapshot {
        return CallStateSnapshot(
            // 네트워크 상태
            networkType: NetworkMonitor.shared.currentType,
            signalStrength: NetworkMonitor.shared.signalStrength,
            
            // 오디오 상태
            audioRoute: AVAudioSession.sharedInstance().currentRoute,
            audioLevel: audioEngine.inputNode.volume,
            
            // 통화 메트릭
            packetLoss: currentCall.stats.packetLoss,
            jitter: currentCall.stats.jitter,
            latency: currentCall.stats.latency,
            mosScore: currentCall.stats.mosScore,
            
            // 디바이스 상태
            batteryLevel: UIDevice.current.batteryLevel,
            thermalState: ProcessInfo.processInfo.thermalState,
            memoryUsage: getCurrentMemoryUsage(),
            
            // 최근 로그 (마지막 100줄)
            recentLogs: LogCollector.shared.getRecentLogs(100)
        )
    }
}

// 자동 이슈 감지
class AutoIssueDetector {
    func detectAudioIssues(_ buffer: AVAudioPCMBuffer) {
        // 1. 묵음 감지
        let silenceDetector = SilenceDetector()
        if silenceDetector.isSilent(buffer) {
            reportIssue(.noAudio, autoDetected: true)
        }
        
        // 2. 에코 감지
        let echoDetector = EchoDetector()
        if echoDetector.hasEcho(buffer) {
            reportIssue(.echo, autoDetected: true)
        }
        
        // 3. 노이즈 레벨
        let noiseLevel = calculateNoiseLevel(buffer)
        if noiseLevel > 0.7 {
            reportIssue(.backgroundNoise, autoDetected: true)
        }
        
        // 4. 클리핑 (오디오 왜곡)
        if detectClipping(buffer) {
            reportIssue(.audioDistortion, autoDetected: true)
        }
    }
}
```

## 실전 디버깅 시나리오

### 시나리오 1: "특정 시간대만 문제 발생"

```swift
// 시간대별 패턴 분석
class TimeBasedAnalysis {
    func analyzeTimePatterns() {
        // Elasticsearch 쿼리
        let query = """
        {
            "aggs": {
                "hourly_stats": {
                    "date_histogram": {
                        "field": "timestamp",
                        "interval": "hour"
                    },
                    "aggs": {
                        "success_rate": {
                            "avg": {
                                "field": "call_success"
                            }
                        },
                        "avg_duration": {
                            "avg": {
                                "field": "call_duration"
                            }
                        }
                    }
                }
            }
        }
        """
        
        // 결과: 오후 6-8시 성공률 30% (평소 90%)
        // 원인: 퇴근 시간 네트워크 혼잡
        // 해결: 
        // 1. 적응형 비트레이트 더 공격적으로
        // 2. 지터 버퍼 크기 증가
        // 3. TURN 서버 자동 스케일링
    }
}
```

### 시나리오 2: "특정 기기에서만 크래시"

```swift
// 디바이스별 분석
class DeviceSpecificDebug {
    func analyzeDeviceCrashes() {
        let crashes = CrashDB.query("""
            SELECT device_model, os_version, COUNT(*) as crash_count
            FROM crashes
            WHERE timestamp > NOW() - INTERVAL '7 days'
            GROUP BY device_model, os_version
            ORDER BY crash_count DESC
        """)
        
        // 결과: iPhone 8, iOS 15.7에서 90% 크래시
        // 원인 조사:
        debugSpecificDevice(model: "iPhone 8", os: "15.7")
    }
    
    func debugSpecificDevice(model: String, os: String) {
        // 1. 메모리 제한 확인
        if model.contains("iPhone 8") {
            // 2GB RAM - 메모리 최적화 필요
            reduceMemoryUsage()
        }
        
        // 2. iOS 버전별 API 차이
        if os.starts(with: "15") {
            // AVAudioSession 버그 우회
            applyiOS15Workaround()
        }
        
        // 3. 하드웨어 코덱 지원
        if !supportsHardwareOpus(model: model) {
            // 소프트웨어 코덱으로 폴백
            useSoftwareCodec()
        }
    }
}
```

### 시나리오 3: "간헐적 오디오 끊김"

```swift
// 오디오 끊김 디버깅
class AudioGlitchDebugger {
    private var audioMetrics: [AudioMetric] = []
    
    func diagnoseAudioGlitches() {
        // 1. 버퍼 언더런 체크
        audioEngine.mainMixerNode.auAudioUnit.scheduleParameterBlock { 
            _, _, frameCount, _, _ in
            
            if frameCount < expectedFrameCount {
                self.recordUnderrun(missedFrames: expectedFrameCount - frameCount)
            }
        }
        
        // 2. CPU 스파이크 연관성
        correlateWithCPUSpikes()
        
        // 3. 네트워크 지터 연관성
        correlateWithNetworkJitter()
        
        // 4. 백그라운드 앱 영향
        checkBackgroundAppsImpact()
    }
    
    func generateDiagnosticReport() -> AudioDiagnosticReport {
        return AudioDiagnosticReport(
            underruns: audioMetrics.filter { $0.type == .underrun },
            overruns: audioMetrics.filter { $0.type == .overrun },
            latencySpikes: audioMetrics.filter { $0.latency > 100 },
            correlations: findCorrelations(),
            recommendations: generateRecommendations()
        )
    }
}
```

## 원격 디버깅 도구

```swift
// 실시간 원격 디버깅
class RemoteDebugger {
    private let webSocket: WebSocket
    
    func enableRemoteDebugging() {
        // 개발 빌드에서만
        #if DEBUG
        webSocket.connect(to: "wss://debug.example.com")
        
        webSocket.onMessage = { message in
            self.handleDebugCommand(message)
        }
        #endif
    }
    
    func handleDebugCommand(_ command: DebugCommand) {
        switch command.type {
        case .getLogs:
            let logs = LogCollector.shared.getAllLogs()
            webSocket.send(logs)
            
        case .getMetrics:
            let metrics = MetricsCollector.shared.getCurrentMetrics()
            webSocket.send(metrics)
            
        case .setLogLevel:
            Logger.shared.level = command.logLevel
            
        case .triggerCrash:
            // 테스트용 크래시
            fatalError("Remote crash test")
            
        case .captureMemoryGraph:
            let graph = captureMemoryGraph()
            webSocket.send(graph)
            
        case .profileCPU:
            startCPUProfiling(duration: command.duration)
        }
    }
}
```

## 포스트모텀 템플릿

```markdown
# 장애 포스트모텀: 2024-09-15 통화 연결 실패

## 요약
- **영향**: 30% 통화 실패율 (3시간)
- **영향 사용자**: ~50,000명
- **근본 원인**: STUN 서버 인증서 만료

## 타임라인
- 02:47 - 첫 알림 (실패율 15%)
- 03:02 - 에스컬레이션 (실패율 30%)
- 03:15 - 원인 파악 시작
- 03:42 - 인증서 만료 확인
- 03:51 - 인증서 갱신
- 04:03 - 서비스 정상화

## 근본 원인
STUN 서버 SSL 인증서가 자동 갱신되지 않음
- Let's Encrypt 갱신 크론잡 실패
- 모니터링이 HTTP만 체크, STUN 프로토콜 미체크

## 해결 방안
1. 즉시: 수동 인증서 갱신
2. 단기: STUN 헬스체크 추가
3. 장기: 인증서 관리 자동화 개선

## 개선 사항
- [ ] STUN/TURN 프로토콜 레벨 모니터링
- [ ] 인증서 만료 30일 전 알림
- [ ] 자동 갱신 실패시 폴백
- [ ] Runbook 업데이트

## 교훈
"모든 프로토콜을 모니터링하라"
```

## 다음은...

이제 당신은 iOS VoIP 앱을 만들 수 있다.
하지만 기억하라:

1. 기술은 수단일 뿐
2. 사용자 경험이 핵심
3. 안정성 > 기능
4. 모니터링 없는 서비스는 없다
5. 실패에서 배우는 것이 성장

"Hello World"에서 "카톡처럼"까지의 여정이었다.
이제 당신만의 여정을 시작하라.